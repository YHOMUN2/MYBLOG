{"meta":{"title":"光田云恒","subtitle":"技术 · 安全 · 随笔","description":"记录代码、渗透、随想","author":"光田云恒","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2025-11-21T12:18:18.000Z","updated":"2025-11-23T04:57:41.843Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2025-11-21T12:18:29.000Z","updated":"2025-11-21T12:18:29.608Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-11-21T12:17:43.000Z","updated":"2025-11-23T04:57:02.624Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MISC","slug":"Sundry/Misc","date":"2025-12-24T13:19:54.463Z","updated":"2025-12-24T13:19:54.463Z","comments":true,"path":"2025/12/24/Sundry/Misc/","permalink":"http://example.com/2025/12/24/Sundry/Misc/","excerpt":"","text":"Nepnep 祝你新年快乐啦！ 方法 1：视频最后一帧 方法 2：使用网页 F12，查看网页源代码，搜索“catctf” flag：CatCTF{H4ppy_n3w_y34r} CatFlag（cat 命令） 下载附件查看，是一串字符，题目给出提示使用cat flag or type flag cat 是 Linux 系统中非常常用的命令，用来 查看文件内容、合并多个文件、创建新文件 等。 type 不是用于查看文件内容的命令，而是 用于查看命令的类型与来源。 它可以告诉你某个命令是： 内建命令（shell builtin） 外部命令（在 /bin、/usr/bin 等路径） 别名（alias） 函数（function） 使用 kali 输入cat '/home/gtyh/桌面/flag' flag：CatCTF{!2023_Will_Be_Special,2022_Was_Not!} CatchCat(GPS 数据流) 题目给出提示，附件中 txt 内容是 GPS 数据流 方法 1：使用网站（根据 GPS 文件生成一个 HTML 地图）https://www.gpsvisualizer.com/map_input 选择文件--&gt; Draw the map --&gt; 跳转网页 --&gt; 等待出现一个地图 --&gt; 旋转 90°--&gt;查看 flag flag：CatCTF{GPS_M1ao} 方法 2：将 txt 文件转为 kml 文件，在使用网站画出上面的图案 备注：KML（Keyhole Markup Language） 是一种基于 XML 的文件格式，用来在地图软件中（如 Google Earth、Google Maps、ArcGIS 等）描述地理信息。 文件扩展名通常是 .kml 或 .kmz（压缩版本）。 CatCatCat（图片--&gt;编码与解码） 解压后的文件展示 这里需要用到 kali 的 strings 命令 输入命令 strings 猫猫.jpg,可以看到 kali 输出了一大串字符， 其中包含关键字符：passwordis..catflag..，可以猜测是解压或转码的密码 我们接着看另外一个 txt 文件里面内容，注意文件名：兔子与 91（rabbit 加密和 base91 编码） 使用在线解码网站进行 Rabbit 解密 使用 base91 解码 将 cat 文本复制到网站中点击 Ook! to Text 即可出现 flag Ook 编码： 只要你看到这种 重复单词 + 标点符号组合（共三种标点）、并且数量众多、像“猫语”一样循环出现， 99% 就是 OOK 编码（或者它的变体，比如把 &quot;Ook&quot; 换成 &quot;cat&quot;）。 Ook! To Text 等价于：把 Ook → 转成 Brainfuck → 执行 → 输出文本。也就是说它做了两步合并（转换 + 运行）。 法二：把下面脚本保存为 ook_decode.py，把你的原始文件（含 cat. 等）放在同目录，假设文件名 ook.txt，然后运行 python ook_decode.py 即可得到输出： #ook_decode.py import re #修改为你的文件名 txt_path = &quot;ook.txt&quot; with open(txt_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: raw = f.read() tokens = re.findall(r&quot;cat[.!?]&quot;, raw) # 找到 cat. cat? cat! ook_tokens = [t.replace(&quot;cat&quot;, &quot;Ook&quot;) for t in tokens] pair_to_bf = { (&quot;Ook.&quot;, &quot;Ook?&quot;): &quot;&gt;&quot;, (&quot;Ook?&quot;, &quot;Ook.&quot;): &quot;&lt;&quot;, (&quot;Ook.&quot;, &quot;Ook.&quot;): &quot;+&quot;, (&quot;Ook!&quot;, &quot;Ook!&quot;): &quot;-&quot;, (&quot;Ook!&quot;, &quot;Ook.&quot;): &quot;.&quot;, (&quot;Ook.&quot;, &quot;Ook!&quot;): &quot;,&quot;, (&quot;Ook!&quot;, &quot;Ook?&quot;): &quot;[&quot;, (&quot;Ook?&quot;, &quot;Ook!&quot;): &quot;]&quot;, } bf = [] for i in range(0, len(ook_tokens)-1, 2): a = ook_tokens[i] b = ook_tokens[i+1] if (a,b) not in pair_to_bf: raise SystemExit(f&quot;Unknown pair: {(a,b)}&quot;) bf.append(pair_to_bf[(a,b)]) bf_code = &quot;&quot;.join(bf) #简单的 Brainfuck 解释器（无输入） def run_bf(code, max_steps=20000000, mem_size=30000): tape = [0]*mem_size ptr = 0 pc = 0 output = [] steps = 0 # 匹配括号 stack = [] match = {} for i,ch in enumerate(code): if ch == &quot;[&quot;: stack.append(i) elif ch == &quot;]&quot;: if not stack: raise ValueError(&quot;Unmatched ] at %d&quot; % i) j = stack.pop() match[i] = j match[j] = i if stack: raise ValueError(&quot;Unmatched [ at %d&quot; % stack[-1]) while pc &lt; len(code) and steps &lt; max_steps: ch = code[pc] if ch == &quot;&gt;&quot;: ptr += 1 elif ch == &quot;&lt;&quot;: ptr -= 1 elif ch == &quot;+&quot;: tape[ptr] = (tape[ptr] + 1) % 256 elif ch == &quot;-&quot;: tape[ptr] = (tape[ptr] - 1) % 256 elif ch == &quot;.&quot;: output.append(chr(tape[ptr])) elif ch == &quot;,&quot;: tape[ptr] = 0 # no input provided elif ch == &quot;[&quot;: if tape[ptr] == 0: pc = match[pc] elif ch == &quot;]&quot;: if tape[ptr] != 0: pc = match[pc] pc += 1 steps += 1 return &quot;&quot;.join(output) print(&quot;Generated BF length:&quot;, len(bf_code)) print(&quot;Executing BF...&quot;) print(run_bf(bf_code)) 放在同一个文件夹下，输入 python ook_decode.py,提交的时候注意将 CATCTF==》CatCTF flag:CATCTF{Th1s_V3ry_cute_catcat!!!} 删库跑路-(文件分离) 使用 010 Editor 查看文件，发现文件大多说是 00 00 00 ，说明：qcow2 是稀疏文件（sparse file）格式： 文件逻辑大小可能几十 MB，但实际占用磁盘只有几 KB。 只有真正写入的数据块才存有内容，其余部分逻辑上存在、物理上未分配（所以都是 00）。 是未使用（空闲）扇区 把文件复制到 kali 中 输入 python3 -m binwalk --run-as=root -e vm-106-disk-1.qcow2 1. binwalk binwalk 是一个静态二进制 / 镜像分析工具，常用于： 扫描文件或磁盘镜像里的 文件签名（magic headers）、压缩段、文件系统头； 自动提取（carve/extract）在镜像中识别出的内嵌文件（比如 gzip、squashfs、tar、jpeg、elf 等）； 在取证 / 逆向 / CTF 中非常常用。 2. -e（或 --extract） -e 的意思是 提取（extract）： binwalk 在扫描到已知签名后，会尝试调用对应的提取器（比如 dd, bunzip2, unsquashfs 等）把识别到的嵌入文件解包出来。 执行后会在当前目录创建一个以源文件名开头的目录，默认命名规则类似： _vm-106-disk-1.qcow2.extracted/ 里面会放置 binwalk 提取出的所有文件和子目录，以及一些日志/偏移信息文件（.dirs, .extracted 等）。 输入命令python3 -m binwalk --run-as=root -e vm-106-disk-1.qcow2 注意： 一开始binwalk -e vm-106-disk-1.qcow2 --run-as=root 这行命令会报错。 python3 -m binwalk 直接让 Python 去加载 binwalk 模块并执行它，不依赖于在系统路径里由 pip/apt 安装的“console_scripts”入口点脚本。之前的 StopIteration 是那个入口点脚本试图通过 pkg_resources 或 importlib.metadata 找到注册的控制台函数，但没有找到或找错了 Python 环境，导致失败；用 -m 绕开了这个中间层，因此能成功运行。 扫描结果，binwalk 识别到三个主要签名： 0x50000（十进制 327680）：ext filesystem（第一个 ext） 0x8091000（十进制 134811648）：gzip 压缩数据 0x10056000（十进制 268787712）：另一个 ext filesystem 对应到提取目录，你现在有： 50000.ext —— 一段被当作 ext（可能含分区/文件系统）的原始块（大小 536870912 字节） 8091000 —— 一个小文件（10240 字节），binwalk 识别为 gzip 段 10056000.ext2 —— 另一个被导出的 ext2/ext 文件（268410880 字节） ext-root —— binwalk 可能已经把其中一个文件系统部分以目录形式解包（如果 binwalk 能直接提取文件树，会放在这里） 当你分离出来后，会发现桌面多一个文件夹，打开 8091000 文件，即可看见 flag flag{c28c424b-fd8c-45b9-b406-0a933b1ca7b1} [简单] 凯撒大帝在培根里藏了什么（培根与凯撒密码） 下载文件，看到文件有一串 ABAB 的字符 解题：AB 串是一个培根密码，接着是一个凯撒密码(思路，题目已经给出提示) 备注： 又叫“培根双字母密码”或“Baconian Cipher”，是由英国哲学家 弗朗西斯·培根（Francis Bacon） 在 1605 年发明的一种隐写密码。它有趣的地方在于，它并不直接改变字母本身，而是通过“文字表面”隐藏信息——像一封普通信中潜藏着另一条暗语。 使用培根密码解码，获得ngbklatcoznixevzu 使用凯撒密码加密，获得一个有语义的一句话即可（这个 20 凑出来的？我不知道） 注意后面要转大写，才能提交成功 flag{HAVEFUNWITHCRYPTO} [简单] 简单的 base 编码 解题思路：先用 bese64 解码 20 次，再用 base92 解码 1 次 下面是 base64 解码 20 次的 python 代码，保存为encode_python.py import base64 with open(&quot;encode.txt&quot;, &quot;r&quot;) as file: data = file.read() for _ in range(20): data = base64.b64decode(data) print(data) 使用 cmd 输入python encode_python.py，注意将连个文件放在同一个文件夹中 获得解码的字符串b'F#S&lt;YRa[$*x7,&gt;{F3DH5N/3.5+J6WD%P841JRN_i51F1Z!' 再用 base92 解码即可，注意只需要引号内的字符F#S&lt;YRa[$*x7,&gt;{F3DH5N/3.5+J6WD%P841JRN_i51F1Z! flag{d0y0u_l1ke_base92!??!_by_Sh3n} 来自银河的信号（音频-&gt;图片-&gt;解码） 下载附件后，是一个音频文件，粗看没有可用信息，我们可以使用音频转图像的方式解题 首先需要下载虚拟音频设备驱动（ VB-CABLE ） VB-CABLE 是一种 虚拟音频设备驱动，安装后系统会多出一个“虚拟声卡”，一般显示为： CABLE Input (VB-Audio Virtual Cable) CABLE Output (VB-Audio Virtual Cable) 可以把它理解为一根“虚拟音频线”，将系统或某个程序的输出声音“接入”到另一个程序的输入中。 然后在设置中声音处的输出/输入，选为 VB-Audio 的虚拟设备 接着我们使用 MMSSTV 软件进行解码，代开软件与音频，让音频处于播放状态，MMSSTV 就会处于一个“听”的状态，就可以解码出相应的图片。 MMSSTV &amp; RX-SSTV 图像解码软件， 是用来解码国际空间站在 145.800Mhz 频率发送的声音的解码成图片的软件。 声音的来源，是能接收 145.800Mhz 频率信号的无线电台（车载台、手台等，就是类似小区保安拿的那种）， 将声音播放给这两款软件&quot;听&quot;，就可以解码出相应的图片。 图片中的文字f7liavga{1M_0105n_cC@okmei_nFge!s}，猜测栅栏密码 栅栏（之字形）重排会产生“看起来乱但字符未变”的结果：栅栏密码只改变字符位置，不改变字符本身（不像凯撒、替换会改变字符）。因此如果我们看到原字符集完整但顺序异常，栅栏是自然的怀疑对象。 flag{M00nc@ke_Fes7iva1_15_Coming!} steg 没有 py 下载附件后，解压看到是一张图片 解题： 时间刺客！（图片基本属性） 下载附件： 解题思路： 查看图片基础属性，修改时间上面有些异常 编写脚本提取时间戳 import os #设置图片所在的目录路径（Windows 反斜杠要么双写 \\\\，要么用 r'' 原始字符串） img_dir_path = r&quot;F:\\CTF\\11.3\\9\\1c606f8f-372c-4519-8303-1a901c87934b\\attachment\\附件&quot; # 获取目录下的所有文件名 img_dir = os.listdir(img_dir_path) flag = &quot;&quot; for image_name in img_dir: # 拼接完整路径 image_path = os.path.join(img_dir_path, image_name) # 获取文件修改时间戳（秒） time_stamp = int(int(int(os.path.getmtime(image_path) * (10**9)) % (2**64 - 1)) / (10**9)) str_time_stamp = str(time_stamp) print(f&quot;{image_name} -&gt; {str_time_stamp}&quot;) # 打印文件名和时间戳 ascii_code = &quot;&quot; for i in range(len(str_time_stamp)): ascii_code += str_time_stamp[i] if int(ascii_code) &gt; 127: ascii_code = ascii_code[:-1] flag += chr(int(ascii_code)) ascii_code = str_time_stamp[i] elif i == len(str_time_stamp) - 1: flag += chr(int(ascii_code)) print(&quot;\\n=== FLAG 结果 ===&quot;) print(flag) 直接再当前目录下的 cmd，输入 python time.py flag{T1m3_f1ie5} 看雪看雪看雪（基础属性-&gt;snow 解码） 下载附件，只有一张图片，查看基础属性：时间、长宽高、详细信息.... 看到照相机型号有些诡异736e6f77212121观察数据，最大的是 f，猜测是十六进制 这串字符转码思路：（16 进制到 ASCII 字符串） 把那连串的十六进制字符（736e6f77212121） 拆成两位一组：73 6e 6f 77 21 21 21。 每组十六进制转成十进制（即每个字节的数值）。 发现得到的每个数都小于 128 → 说明它们落在 ASCII 可显示字符范围 → 把这些数按 ASCII 表转成字符。 转换后的字符连起来就是 snow!!!。 直接编写一个 py 脚本，帮我们转码，最后输出一个 snow ，去提交 flag,并不是最终答案 # -*- coding: utf-8 -*- # 题目：将十六进制字符串转为 ASCII 字符串 # 定义函数：十六进制 → 十进制列表 def solution(s): &quot;&quot;&quot; 将输入的十六进制字符串（'736e6f77212121'） 每2个字符为一组，转换为对应的十进制整数（即字节值）。 &quot;&quot;&quot; i = 0 list1 = [] # 用于存储十进制结果 while i &lt; len(s): str1 = s[i:i+2] # 每次取2个十六进制字符 c = int(str1, 16) # 转换为十进制整数 list1.append(c) # 加入结果列表 i += 2 # 前进两位 return list1 # 一串十六进制字符串 str_1 = '736e6f77212121' #输出原字符串 print(&quot;原字符串：&quot;, str_1) # 调用函数，将十六进制转成十进制列表 b = solution(str_1) # 打印结果1：十进制列表 print(&quot;十进制列表：&quot;, b) # 打印结果2：将十进制列表转为 ASCII 字符串 # chr() 将数字转为对应的 ASCII 字符 flag = ''.join(chr(x) for x in b) print(&quot;转换为 ASCII 后的结果：&quot;, flag) 还有一种叫 SNOW 隐写术，关于这个密文，有一个工具，点击以下链接，获取 SNOW 解码工具 Snow 隐写 是一种古老但巧妙的 文本隐写技术， 通过在 纯文本文件（如 .txt） 的 空格和制表符（tab） 中隐藏信息。 名称 “Snow”（雪）来自于“文本中的空白像雪一样覆盖信息”的比喻。 普通文本看起来比如这样： Hello, this is a message. 但 Snow 隐写会在行尾或单词间加上不可见空白字符（space/tab），这些空白按特定规则编码成二进制： Hello, this is a message.␣␣␉␣␣␉␉␣␣ （上面的 ␣ 表示空格，␉ 表示制表符） 这些空白组合编码成 0/1，再转成 ASCII 或加密文本，从而隐藏信息。 使用 7zip 查看压缩包，发现了其他的文件，只要右键点击查看了（很多 UP 都没说这点）前三个连在一起是 他朝若是同淋雪 ，这是 key，第四个是 flag，需要 SNOW.exe 解码的 把第四个文本中的文字全部复制（CTRL+A），包括空格，这也是解密的关键，你也可以点击文件另存为 再 SNOW 工具上使用 CMD，注意输入的格式 -C 表示解码（decode） -p 表示 password ，后面写密码 SNOW.exe -C -p 他朝若是同淋雪 F:\\CTF\\11.3\\10\\misc.jpg_flag.txt flag{Sn0w_M@n!!!!!!!} 流量分析 2（流量中的异常包 flag/test） 打开文件查看统计-&gt;协议分级 情况：正常 “协议分级”是 Wireshark 的一种统计树状图，展示不同协议在抓包中出现的层次关系与占比，用来分析流量结构和发现异常。 每一层的缩进表示“被包含”的关系： Ethernet 是最外层。 里面封装了 IPv4。 IPv4 又封装了 TCP 或 UDP。 TCP 之上可能是 HTTP。 所以它体现了网络协议的封装结构，也说明在你的抓包文件中，哪类协议出现得多、哪类少。 再往下翻数据包，发现可以文件 test.txt 可以输入frame contains &quot;test.txt&quot;，进行过滤数据包 备注： 在整个数据帧中查找任意地方包含 “test.txt” 字符串的包。 接着我点击文件导出 http 即可 之后保存全部 打开全部 test，合并到一个上，即可看到 flag，少了 ag，自己补上 flag{17uaji1l} nice_bgm（音频 private_bit 隐藏） 下载附件是一个 MP3 文件（名侦探柯南背景音乐） 查看基础信息，无诡异之处 再用 binwalk 分离文件，没有东西，python3 -m binwalk --run-as=root -e 1.mp3 我们再查看一下音频的频谱图，没啥异常 import numpy as np import matplotlib.pyplot as plt from scipy.io import wavfile from pydub import AudioSegment #1.读取 MP3 文件并转换为 WAV 格式 audio = AudioSegment.from_file(&quot;1.mp3&quot;, format=&quot;mp3&quot;) audio = audio.set_channels(1) # 转为单声道 audio.export(&quot;temp.wav&quot;, format=&quot;wav&quot;) #2. 读取 WAV 文件 fs, data = wavfile.read(&quot;temp.wav&quot;) #3.快速傅里叶变换（FFT） N = len(data) fft_data = np.fft.fft(data) freqs = np.fft.fftfreq(N, 1/fs) #4.只取正频部分（实信号对称） half_N = N // 2 freqs = freqs[:half_N] amplitude = np.abs(fft_data[:half_N]) / N #5.绘图 plt.figure(figsize=(10, 6)) plt.plot(freqs, amplitude) plt.title(&quot;Frequency Spectrum of 1.mp3&quot;) plt.xlabel(&quot;Frequency (Hz)&quot;) plt.ylabel(&quot;Amplitude&quot;) plt.grid(True) plt.tight_layout() plt.show() 接着我们召唤 010editor 来分析一波，注意打开运行模块（alt+4） 咱们开始先看一个正常的 mp3 文件的模板结果注意private_bit,这个字段的值全都是 0，就是未经修改过的。 private_bit 是什么？ 在 MP3 的帧头（frame header）里，有一位叫 private_bit 的字段。 它的官方定义非常简洁——甚至有点敷衍： “这一位不被标准定义，可由编码器（或其他程序）自由使用。” 译成直白的话就是： 这是 MP3 标准留给厂商、工具、玩家的“自由位”，它没有固定用途，你想写什么就写什么。 它本来 不应该影响音频播放。 为什么你会觉得它被“隐藏信息”使用？ 因为在正常、干净、常规编码器输出的 MP3 里： private_bit 通常保持为 0。 MP3 标准允许它为 1，但常规编码器一般不会去动它，除非： 编码器内部有自己的标识用途（非常少见）。 有某个程序故意在 MP3 的每帧里塞点信息（CTF、隐写、某些 DRM、厂商私有元数据）。 用于 steganography 的工具动过它（常见于 CTF 隐写题）。 你会“觉得有问题”，本质原因是： 你看到一段音频，多帧 private_bit 本应为 0，却出现大量 1，而且呈现某种规律——这是异常现象。 在音频标准里，没有任何理由让一个轻度、普通 MP3 文件把 private_bit 随机置 1。 接着我们打开题目的 1.mp3 文件，查看 private_bit 字段，我们可以注意到他的大多数的值都为 1，就可以猜测他在音频的帧里面隐藏了信息。 好了我们就有思路了：搞一个 python 脚本，批量扫描 MP3 文件的每帧 private_bit 并把 bit 流拼成二进制/ASCII。 第一帧的地址 注意“开始”的一栏 399D0 编写 python 脚本 import textwrap list_private_bit = [] #帧序列开头的地址 first_frame_index = int(&quot;399D0&quot;, 16) with open(&quot;1.mp3&quot;, &quot;rb&quot;) as f: #将文件指针移动到第一帧开头 f.seek(first_frame_index) #因为从010Editor上看到总共有5910帧 for i in range(5911): #每一帧的帧头部数据占4字节，而私有位和padding位恰好在第三字节的 data = f.read(4)[2] #提取私有位并添加到列表中 list_private_bit.append(data &amp; 0b00000001) #提取padding位 = (data &gt;&gt; 1) &amp; 0b00000001 #如果padding位为0，则说明该帧大小为417字节，否则为418字节；方便文件指针精准定位到下一帧的开头 if padding_bit == 0: first_frame_index += 417 else: first_frame_index += 418 f.seek(first_frame_index) #处理提取完成后的私有位，转为文本后输出得到flag list_private_bit_str = list(map(str, list_private_bit)) bits_wrapped = textwrap.wrap(&quot;&quot;.join(list_private_bit_str), 8) flag = &quot;&quot; for words in bits_wrapped: flag += chr(int(words, 2)) print(flag) flag{0k4_YOu_Seem_s0_cl3ver_t0_find_f1ag!} fakezip（压缩包头文件） 首先下载附件，再解压，文件的时候，发现是个加密的 flag.png 我们尝试使用 fcrackzip 工具解密， fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt '/root/桌面/0cb6f418-26ab-40ec-86db-ec7134b27e67.zip' 用 rockyou 字典做字典攻击，且每尝试一个密码都会用 unzip 去验证能否成功解压。 fcrackzip：工具名，用于破解 ZIP 文件密码（纯 CPU、单线程程序，常见于 Kali）。 -u：使用 unzip 来验证密码是否正确（比仅做内部校验更可靠；会尝试解压测试）。 -D：使用字典模式（dictionary attack）。配合 -p 使用。 -p /usr/share/wordlists/rockyou.txt：指定字典文件（这里用 Kali 默认的 rockyou.txt）。 '/root/桌面/0cb6f418-....zip'：要破解的 ZIP 文件路径（单引号是为了处理路径中的空格或特殊字符）。 文件已经 corrupted ，也就是损坏了 接着使用 010editor ，确认压缩包的加密是否为真（有伪加密的情况） 补充知识点： zip 源文件的数据区，特征码 50 4B 03 04 这是 zip 源文件的目录区，特征码 50 4B 01 02 注意到我框中的 01 了吗？数据区与目录区后面的框中的字符 都为 01，为真加密； 都为 00，为未加密； 这边举个例子，我是拿了个文本加密前后对比 真加密的压缩包，若直接更改 01 变 00，里面的内容会不正常 但是题目中的压缩包不一定了，咱们试试 就是这样的一个思路，直接可以解出 flag flag{39281de6-fe64-11ea-adc1-0242ac120002} Check（图片 LSB（最低有效位）隐写+HTML） 下载附件，可以正常解压，是一个图片， 直接使用 010editor 查看一下，文件头与文件尾，都没问题 若任意一处不符合，则该文件要么被破坏、要么被伪装为 PNG。 使用 kali 直接使用 zsteg 工具zsteg -a check.png zsteg 的工具作用 自动检测 LSB（最低有效位）隐写。 可分析隐藏在每个颜色通道（R、G、B、Alpha）的二进制信息。 能识别隐藏文本、ZIP、PNG、base64 等。 发现那条字符串的 HTML 实体：它就是 flag 的字节码。 也可以使用 windons 版的 StegSolve 进行图片分析，在 Order setting 的选项中，可以随意点（不知道的话，自己可以随意试试）然后保存去查看文件即可 这个文件中用文本打开，查看是否有可读文字 复制下来，这文字是 HTMl 编码的，也可以用随波逐流一键解码，搜索 flag/ctf/CTF/Key 要快速判断是不是 HTML 编码： 看有没有 &amp; 开头、; 结尾； 看中间是不是 # 加数字，或者某种单词（lt、gt、amp 等）； # decode_entities.py s = &quot;&amp;#x66;&amp;#x6c;&amp;#x61;&amp;#x67;&amp;#x7b;&amp;#x68;&amp;#x30;&amp;#x77;&amp;#x5f;&amp;#x34;&amp;#x62;&amp;#x6f;&amp;#x75;&amp;#x54;&amp;#x5f;&amp;#x65;&amp;#x6e;&amp;#x63;&amp;#x30;&amp;#x64;&amp;#x65;&amp;#x5f;&amp;#x34;&amp;#x6e;&amp;#x64;&amp;#x5f;&amp;#x70;&amp;#x6e;&amp;#x47;&amp;#x7d;m&quot; import re chars = re.findall(r'&amp;#x([0-9a-fA-F]+);', s) print(''.join(chr(int(h,16)) for h in chars)) # 输出: flag{h0w_4bouT_enc0de_4nd_pnG} flag{h0w_4bouT_enc0de_4nd_pnG} wire1（SQL 注入+ascii） 一开始我只看到了 text/html,他也是 HTTP 流量，误打误撞的在导出的时候，发现了关于 flag 的语句， 过滤一下frame contains &quot;flag&quot;然后继续观察，这是一个 SQL 注入语句。 一个小技巧 若你不清楚 wireshark 的过滤语句怎么写时，先找流量包中的疑点，然后观察这些疑点流浪包的共同点是什么，这题的共同点是 GET，那就点开这条流量包，右击 GET，选择作为过滤器，即可 frame contains &quot;flag&quot; 导出的时候，继续观察，在大小的一栏，总会在一堆 720 长度中出现 704 长度的流量包 备注： 720 / 704不是标准 HTTP 状态码（标准是 200、404、500 等），所以常见含义是响应长度（字节数）或抓包工具显示的数据长度。在 CTF/流量题中，你看到“注入失败 720；注入成功 704”的印象，非常符合“当条件为真/假，服务器返回的页面大小不同”这一典型现象。 请求行（SQL 注入）： GET /ctf/Less-5/?id=1'%20and%20ascii(substr((select%20flag%20from%20t),1,1))=95--+ HTTP/1.1 逐段解释： id=1' 把一个单引号插入到原来的 id=1 参数后，试图结束应用原本的 SQL 字符串/数值字面量，进入注入位置。 %20 是 URL 编码的空格（space）。 and ascii(substr((select flag from t),1,1))=95 这是布尔判断，用来询问数据库：table **t** 中 **flag** 的第 1 个字符的 ASCII 值是否等于 95？ - select flag from t：取出 flag（注意：如果表或列名不同，需要相应调整）。 - substr(...,1,1)：取第 1 个字符（不同 DBMS 关键字可能是 substring()、substr()、SUBSTRING() 等）。 - ascii(...)：返回字符的 ASCII 值（某些 DBMS 使用 ascii()，有些用 ord()）。 - =95：判断是否等于 95（ASCII 95 即 _ 下划线）。 --+ SQL 注释，把后面的原查询剩余部分注释掉。+ 只是 URL 编码里的空格占位常见写法（等价于空格），也有用 /*``*/ 等方式。 把注入成功的语句 704 合并在一起，进行十进制转 ascii 码，上面的注入语句有提示了。 102 108 97 103 123 119 49 114 101 115 104 65 82 75 95 101 122 95 49 115 110 116 105 116 125 flag{w1reshARK_ez_1sntit} Encode（解码） 下载附件，是一个密文 4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35 解密顺序：ROT13--&gt;base16--&gt;base32--&gt;base64--&gt;base64--&gt;base85 我密码不是很好，真的看不出来是 rot 编码，接下来就是一个 base 套娃了（题目有提示，随波逐流直接秒了） ROT13（“rotate by 13 places”）是一种古老的、非常简单的**凯撒位移密码（Caesar cipher）**变体。 👉 原理： 把所有的 英文字母（A-Z / a-z） 在字母表中向后移动 13 位。 超过 Z 则回到 A 开始。 📌 注意： 只对 字母 起作用； 数字、符号、大小写 不变； 加密两次（ROT13(ROT13(x))) 会还原原文。 flag{W0w_y0u_c4n_rea11y_enc0d1ng!} 1-misc（压缩包密码） 使用 archpr 工具 直接暴力破解了，密码20001228 输入 20001228 密码，成功揭开密码 使用 7zip 打开压缩包，这边注意到 CRC 相同，然后使用明文攻击 CRC32（循环冗余校验，32 位）是一种常用的校验和算法，用来检测数据在传输或存储中是否被破坏。对同一字节序列，CRC32 相同==》 嵌套压缩包里出现了“相同内容的文件”被重复压缩/加密 这给攻击者提供了已知明文的机会：你已经知道（或能获得）某一份文件的明文内容，而另一份加密文件对应的就是相同的明文。 “明文攻击”是密码学里的一类攻击模型，常见类型有： 已知明文攻击（Known-plaintext attack，KPA）：攻击者知道（或能获得）某些明文及其对应密文，利用这些对来恢复密钥或解密其它密文。 选择明文攻击（Chosen-plaintext attack，CPA）：攻击者可以选择任意明文并得到其密文。 选择密文攻击（Chosen-ciphertext attack，CCA）：攻击者可以提交密文并得到相应的明文（或部分信息）。 这里属于 已知明文攻击（known-plaintext）：因为你通过解出外层压缩包得到了一个明文图片（或至少得到了该图片的完整内容），而同 CRC32 的图片在另一个受保护的压缩包中对应相同的明文 → 这就是已知明文。 注意执行明文攻击时，需要使用相同文件类型 将 fakeflag.jpg 压缩成 zip 格式，确保 CRC32 相同 一开始我使用 kali 与 7zip 压缩，都会在明文攻击时以下弹出 ARCHPR 错误 这题是使用 winrar 进行压缩，就可以成功 有提示，没有密码，那就是伪密码 直接投入 010 editor 简单修改一下，在解压出来，虽然会显示压缩包损坏，但是 flag.txt 被解压出来了 zip 源文件的数据区，特征码 50 4B 03 04 zip 源文件的目录区，特征码 50 4B 01 02 只要把头文件后面的奇数改为 00 即可，如果不知道改哪个，都去试试就行，保存文件，然后点击压缩包里的 flag 文件，若能打开 flag 就是修改成功了，不然还是会跳输入密码的弹窗的 flag{159c6275f0015c037e70a118f25b9a99} 碎纸机 11（图片合并） 有 50 张图片，直接合并在一起看看 直接全选拖进去图片合并，注意按照日期排序，自己多试试，就知道了 使用 python 合并，注意修改图片路径 模式名 说明 mtime_asc 按修改时间升序（旧 → 新） mtime_desc 按修改时间降序（新 → 旧） ctime_asc 按创建时间升序 ctime_desc 按创建时间降序 size_asc 按文件大小升序 size_desc 按文件大小降序 name_asc 按文件名字典序升序 name_desc 按文件名字典序降序 numeric_name 按文件名中的数字排序（推荐用于 1.png, 2.png, 10.png） from PIL import Image import os # 定义要拼接的文件夹路径 folder_path = './images' # 获取所有图片文件 image_files = [f for f in os.listdir(folder_path) if f.lower().endswith(('.jpg', '.png'))] # ============================== # 选择排序方式（根据需要修改） # ============================== sort_mode = &quot;name_asc&quot; # 可选项：mtime_asc / mtime_desc / name_asc / name_desc / size_asc / size_desc / ctime_asc / ctime_desc / numeric_name # 根据排序方式定义 key if sort_mode == &quot;mtime_asc&quot;: # 按修改时间升序 key_func = lambda f: os.path.getmtime(os.path.join(folder_path, f)) reverse = False elif sort_mode == &quot;mtime_desc&quot;: # 按修改时间降序 key_func = lambda f: os.path.getmtime(os.path.join(folder_path, f)) reverse = True elif sort_mode == &quot;ctime_asc&quot;: # 按创建时间升序 key_func = lambda f: os.path.getctime(os.path.join(folder_path, f)) reverse = False elif sort_mode == &quot;ctime_desc&quot;: # 按创建时间降序 key_func = lambda f: os.path.getctime(os.path.join(folder_path, f)) reverse = True elif sort_mode == &quot;size_asc&quot;: # 按文件大小升序 key_func = lambda f: os.path.getsize(os.path.join(folder_path, f)) reverse = False elif sort_mode == &quot;size_desc&quot;: # 按文件大小降序 key_func = lambda f: os.path.getsize(os.path.join(folder_path, f)) reverse = True elif sort_mode == &quot;name_desc&quot;: # 按文件名降序 key_func = lambda f: f reverse = True elif sort_mode == &quot;numeric_name&quot;: # 按数字命名排序（例如 1.png, 2.png, 10.png） key_func = lambda f: int(''.join(filter(str.isdigit, f)) or 0) reverse = False else: # 默认：按文件名升序 key_func = lambda f: f reverse = False # 执行排序 image_files = sorted(image_files, key=key_func, reverse=reverse) print(&quot;排序方式:&quot;, sort_mode) print(&quot;排序结果:&quot;, image_files) # 计算拼接后图片尺寸 images = [Image.open(os.path.join(folder_path, img)) for img in image_files] widths, heights = zip(*(i.size for i in images)) total_width = sum(widths) max_height = max(heights) # 创建新图像并拼接 new_image = Image.new('RGB', (total_width, max_height)) x_offset = 0 for im in images: new_image.paste(im, (x_offset, 0)) x_offset += im.width # 保存输出文件 output_path = os.path.join(folder_path, 'out.png') new_image.save(output_path) print(f&quot;拼接完成：{output_path}&quot;) 最后合并的图片展示 使用 QR Research 进行扫描 flag{You Can Repair A Picture From Splices Baesd On Entropy} Let_god_knows（图片+Red plane） 下载附件，可知是一张图片.bmp 观察图片基础属性，再用 binwalk 与 foremost 进行文件提取，未发现异常。 接着咱们使用 StegSolve 工具,进入 StegSolve 界面时，首先看一下 file Format（文件格式分析），可以看到给出提示， Color table computed start: 36(normally 0x36, if not then possible hidden data at that point) 我们点击界面下面的箭头，一个一个观察，你会在 Red plane 0 的地方，发现“道”字上面的二维码。直接保存下来 Red plane 0 是什么 “Red plane 0” 就是 红色通道的第 0 位（最低位）。 这意味着：StegSolve 显示的是每个像素的红色分量的最低一位（LSB），并把这位的值（0 或 1）渲染成黑（0）或白（1）。 很多隐写技术（LSB 隐写）就是利用了人眼对颜色微小变化不敏感的特性—— 修改像素的最低一位不会影响肉眼看到的颜色，但能携带二进制信息。 裁剪一下图片，只需要使用 CQR 工具扫描二维码即可获取 flag flag{Ok@y!G0d_know5_n0w} misc2-1（图片逆序输出） 下载附件，一张打不开的是图片，查看基础属性，无异常 放入 010editor 中，发现反序字母，可以使用 python 脚本直接跑出来 # 更安全的按块处理（不会一次性读完整个文件） with open('task_flag.jpg', 'rb') as fin, open('out.jpg', 'wb') as fout: while True: chunk = fin.read(4) # 读最多4字节 if not chunk: break fout.write(chunk[::-1]) # 写入反转后的字节 # 以二进制模式 ('rb') 打开 task_flag.jpg， # 一次性把整个文件读进内存，f1 是 bytes 类型，包含整个文件内容 f1 = open('task_flag.jpg', 'rb').read() f1_len = len(f1)#得到文件字节长度（整数）。 f2 = open('out.jpg', 'ab') #以二进制追加模式 ('ab') 打开（或创建）out.jpg，写入的数据会被追加到文件末尾（如果多次运行，会不断追加）。 i = 0 while i &lt; f1_len: #f1[i:i+4]：从 f1 中取出从 i 开始的至多 4 字节 #[::-1]将这段 bytes 反转（字节顺序倒置） f2.write(f1[i:i+4][::-1]) #用 i 作为偏移，每次步进 4 字节，循环遍历 f1 的所有字节块（按 4 字节一组）。 i = i + 4 f2.close()#关闭输出文件句柄。 使用 PuzzleSolver 工具进行文件逆向，他会输出一个文件夹，在其中直接可以看到 flag 我们打开逆向后的图片，可以看到正序的Adobe Photoshop CS6 (Windows) 2018:10:22 10:07:45 flag{F098996689560BBB1B566EBC10D5E564}","categories":[{"name":"Misc","slug":"Misc","permalink":"http://example.com/categories/Misc/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://example.com/tags/Misc/"}]},{"title":"计算机组成期末复习","slug":"School/计算机组成期末复习","date":"2025-12-21T02:11:20.591Z","updated":"2025-12-21T02:16:56.540Z","comments":true,"path":"2025/12/21/School/计算机组成期末复习/","permalink":"http://example.com/2025/12/21/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"1、计算机系统概述 冯・诺依曼计算机的特点是什么？ 1.存储程序和程序控制： 存储程序：将解题的步骤编制成程序，然后将程序和运行程序所需要的数据以二进制的形式存放到存储器中，方便执行。 程序控制：计算机中的控制器逐条取出存储器中的指令并按顺序执行，控制各功能部件进行相应的操作，完成数据的加工处理。 2.指令和数据以二进制形式存储 3.“五大部件”：存储器、控制器、控制器、输入设备、输出设备 冯诺依曼机说明各部件的功能和性能指标。 计算机系统的层次结构是如何划分的？这样划分的意义是什么？各层次在计算机系统中有什么作用？ 冯诺依曼结构计算机的基本思想是什么？按此思想设计的计算机硬件系统应当由哪些部件组成？各有什么作用？ 2、数据信息的表示 由 3 个 “1” 和 5 个 “0” 组成的 8 位二进制补码，能表示的最小整数是多少？为什么计算机中采用二进制进行数据的表示和运算？ 3、运算方法和运算器 已知 [x] 补 = 1.1001，[y] 补 = 1.1110，用变形补码求 2 [x] 补 + 1/2 [y] 补，同时指出运算结果是否溢出。 已知 [x] 补和 [y] 补，计算下列各题。 (1)[x] 补 = 0.11011，[y] 补 = 1.01011，求 [x+y] 补和 [x-y] 补。 (2)[x] 补 = 1.01010，[y] 补 = 1.00100，求 [x+y] 补和 [x-y] 补。 移位运算和乘法及除法运算有何关系？ 4、存储系统 主存的地址寄存器和数据寄存器各自的作用是什么？设一个 1MB 容量的存储器，字为32位，问: (1) 按字节编址，地址寄存器和数据寄存器各几位？编址范围为多大？(2) 按字编址，地址寄存器和数据寄存器各几位？编址范围为多大？用一个 512Kx8 位的 Flash 存储芯片组成一个 4Mx32 位的半导体只读存储器，存储器按字编址，试回答以下问题: (1) 该存储器的数据级数和地址线数分别为多少？ (2) 共需要几片这样的存储芯片？ (3) 说明每根地址线的作用。 什么是动态存储器？ 什么是静态存储器？ 计算机系统中采用层次化存储体系结构的目的是什么？其体系结构中包含什么部件？对于 32KB 容量的存储器，若按 16 位字编址，其地址寄存器应是多少位？数据寄存器是多少位？ 用 4 个 32Kx8 位 SRAM 存储芯片可设计出哪几种不同容量和字长的存储器？画出相应设计图并完成与 CPU 的连接。 用 32Kx8 位 RAM 芯片和 64Kx4 位 ROM 芯片设计 256Kx8 位存储器。其中，从30000H到 3FFFFH 的地址空间为只读存储区，其他为可读、可写存储区。完成存储器与CPU的连接。 某计算机字长为 16 位，主存容量为 128Kx16 位，请用 16Kx8 位的静态RAM芯片和32Kx16 位的 ROM 芯片为该机设计一个主存储器。要求 18000H~IFFFFH 为ROM区，其余为 RAM 区。 5、指令系统 指令和数据都存在主存中，计算机是如何区分它们的？ 某计算机指令系统若采用定长操作码和可变长指令码格式，请回答以下问题: (1) 采用什么寻址方式指令码长度最短？什么寻址方式指令码长度最长？(2) 采用什么寻址方式执行速度最快？什么寻址方式执行速度最慢？(3) 若指令系统采用定长指令码格式，那么采用什么寻址方式执行速度最快？什么是定长指令和变长指令，其区别是什么？ 设寄存器 R 中的数值为 1000H，地址为 1000H 的存储单元中存储的内容为2000H，地址为 2000H 的存储单元中存储的内容为 3000H，PC 的值为 4000H，问以下寻址方式下访问到的操作数的值是什么？并解释原因。 （1）寄存器寻址 R； （2）寄存器间接寻址（R）； （3）直接寻址 1000H； （4）间接寻址（1000H）； （5）相对寻址－2000H（PC）。 什么叫指令？什么叫指令系统？ 计算机中为什么要设置多种操作数寻址方式？ 操作数寻址方式在指令中如何表示？ 基址寻址和变址寻址的作用是什么？分析它们的异同点。 指令的地址码与指令中的操作码含义有何不同？ 根据操作数所在的位置，在空格处填写其寻址方式。 (1) 操作数在指令中为______寻址方式。 (2) 操作数地址 (主存) 在指令中为______寻址方式 (3) 操作数在寄存器中为______寻址方式。 (4) 操作数地址在寄存器中为______寻址方式。 某计算机字长为 16 位，运算器为 16 位，有 16 个通用寄存器，8 种寻址方式，主存为128KW, 指令中操作数地址码由寻址方式字段和寄存器号字段组成。请回答下列问题。(1) 单操作数指令最多有多少条？ (2) 双操作数指令最多有多少条？ (3) 直接寻址的范围多大？ (4) 变址寻址的范围多大？ 6、中央处理器 RISC 处理器有何特点？ CPU 的基本功能是什么？从实现其功能的角度分析，它应由哪些部件组成？CPU 内部有哪些寄存器？功能分别是什么？哪些是程序员可见的？哪些是必需的？什么是取指周期？取指周期内应完成哪些操作？ 计算机为什么要设置时序系统？说明指令周期、机器周期和时钟周期的含义。简述传统三级时序和现代时序的差异。 比较单周期 MIPS 处理器与多周期 MIPS 处理器的差异。 组合逻辑控制器与微程序控制器各有什么特点？ 7、指令流水线 简述指令流水线的特点 8、总线系统 计算机系统为什么采用总线结构？ 比较单总线、双总线、三总线结构的特点？ 总线的信息传送方式有哪几种，各有什么特点？ 9、输入输出系统 什么是中断？什么是中断源？常见的中断源有哪几种？ 什么是 DMA?有何先进之处 中断处理过程包括哪些操作步骤？ 什么是多重中断？实现多重中断的必要条件是什么？ 简述中断系统中采用屏蔽的作用。 主机与各种 I/O 设备之间交换信息的方式有几种？各有何特点？ CPU 和外部设备之间如何连接？ CPU 和外部设备信息交换的控制方式有哪些？各有什么特点？","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}]},{"title":"tags与categories的3D页面","slug":"博客搭建/tags与categories的3D页面","date":"2025-11-23T04:45:30.586Z","updated":"2025-11-23T06:22:05.116Z","comments":true,"path":"2025/11/23/博客搭建/tags与categories的3D页面/","permalink":"http://example.com/2025/11/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/tags%E4%B8%8Ecategories%E7%9A%843D%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"Tags 页面 &lt;%- partial('partials/header') %&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1 class=&quot;header-title center&quot;&gt;Tags&lt;/h1&gt; &lt;/header&gt; &lt;!-- 3D 标签球 --&gt; &lt;div style=&quot;text-align:center; margin: 40px 0;&quot;&gt; &lt;canvas id=&quot;tagCanvas&quot; width=&quot;450&quot; height=&quot;450&quot;&gt;&lt;/canvas&gt; &lt;!-- Tag 列表（供 JS 读取，但隐藏） --&gt; &lt;div id=&quot;tagList&quot; style=&quot;display:none;&quot;&gt; &lt;% if (site.tags &amp;&amp; site.tags.length) { %&gt; &lt;% site.tags.sort('name').each(function(tag){ %&gt; &lt;a class=&quot;tag-item&quot; href=&quot;&lt;%- url_for(tag.path || ('/tags/' + tag.name + '/')) %&gt;&quot;&gt;&lt;%= tag.name %&gt;&lt;/a&gt; &lt;% }) %&gt; &lt;% } %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;&lt;%- url_for('/js/tagcanvas.js') %&gt;&quot;&gt;&lt;/script&gt; &lt;script&gt; function getTagColor() { return document.body.getAttribute('data-theme') === 'dark' ? '#eaeaea' : '#333'; } document.addEventListener('DOMContentLoaded', function () { if (typeof TagCanvas === 'undefined') return; const items = document.querySelectorAll('#tagList .tag-item'); if (!items || items.length === 0) return; const sphere = new TagCanvas('tagCanvas', { radius: 180, speed: 0.004, font: '18px Arial', color: getTagColor() }); const observer = new MutationObserver(function () { sphere.color = getTagColor(); }); observer.observe(document.body, { attributes: true }); }); &lt;/script&gt; &lt;%- partial('partials/foot') %&gt; Categories 页面 &lt;%- partial('partials/header') %&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1 class=&quot;header-title center&quot;&gt;Categories&lt;/h1&gt; &lt;/header&gt; &lt;div style=&quot;text-align:center; margin: 40px 0;&quot;&gt; &lt;canvas id=&quot;catCanvas&quot; width=&quot;450&quot; height=&quot;450&quot;&gt;&lt;/canvas&gt; &lt;!-- 分类列表 --&gt; &lt;div id=&quot;categoryList&quot; style=&quot;display:none;&quot;&gt; &lt;% if (site.categories &amp;&amp; site.categories.length) { %&gt; &lt;% site.categories.sort('name').each(function(cat){ %&gt; &lt;a class=&quot;tag-item&quot; href=&quot;&lt;%- url_for(cat.path || ('/categories/' + cat.name + '/')) %&gt;&quot;&gt;&lt;%= cat.name %&gt;&lt;/a&gt; &lt;% }) %&gt; &lt;% } %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;&lt;%- url_for('/js/tagcanvas.js') %&gt;&quot;&gt;&lt;/script&gt; &lt;script&gt; function getTagColor() { return document.body.getAttribute('data-theme') === 'dark' ? '#eaeaea' : '#333'; } document.addEventListener('DOMContentLoaded', function () { if (typeof TagCanvas === 'undefined') return; const items = document.querySelectorAll('#categoryList .tag-item'); if (!items || items.length === 0) return; const sphere = new TagCanvas('catCanvas', { radius: 180, speed: 0.004, font: '18px Arial', color: getTagColor() }); const observer = new MutationObserver(function () { sphere.color = getTagColor(); }); observer.observe(document.body, { attributes: true }); }); &lt;/script&gt; &lt;%- partial('partials/foot') %&gt;","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"BLOG","slug":"BLOG","permalink":"http://example.com/tags/BLOG/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"Hexo 项目结构","slug":"博客搭建/Hexo 项目结构","date":"2025-11-22T12:49:09.483Z","updated":"2025-11-22T13:13:49.102Z","comments":true,"path":"2025/11/22/博客搭建/Hexo 项目结构/","permalink":"http://example.com/2025/11/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%20%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"📄 _config.yml（全局配置） 这是 Hexo 主配置文件，你最常改的就是它。 实际要改的典型配置： title / subtitle：博客名 theme：你要用的主题名称 url：你部署到 GitHub Pages 或服务器时的域名 deploy: Git 部署参数 你现在正在改 theme: next，就属于这里。 📁 themes/ 放主题的目录。 每个主题就是一个独立项目，比如： themes/ ├─ next/ ├─ yilia-plus/ └─ butterfly/ 你只需在 _config.yml 写： theme: next 就能切换主题。 主题不是 npm 包，是 Git 项目，所以你可以： cd themes/next git pull 来更新主题。 📁 source/ 你的文章内容放这里。 里面一般有： source/ ├─ _posts/ # Markdown文章都放在这里 ├─ images/ # 图片 └─ about/ # 独立页面 当你执行： hexo new post &quot;标题&quot; 它会自动生成： source/_posts/标题.md 你基本 90% 时间都在改这里。 📁 scaffolds/ Hexo 新建文章时用的 模板。 比如你执行： hexo new page &quot;about&quot; 它会按照 scaffolds 模板生成初始内容。 你几乎不会改它，但 CTF 或自动化脚本想自定义文章头部格式时会用。 📁 public/ 执行： hexo generate # 或 hexo g Hexo 会把整个博客编译成静态网页输出到这里。 里面都是 HTML / CSS / JS 等最终结果。 你部署（上传）到 GitHub Pages 或服务器时，就是把这个目录里的内容上传。 你不要手动修改它，每次 hexo g 都会被覆盖。 📁 node_modules/ npm 装的依赖都在这，比如： hexo hexo-server hexo-generator-* 主题依赖 这个目录通常几百 MB，很大。 不用管它，不要动它。 📄 package.json Hexo 项目的依赖声明文件。 包含： hexo 的版本 hexo 插件 你主题需要的 npm 包 有时主题要求你装额外插件，就会在这里出现： &quot;hexo-renderer-marked&quot;: &quot;^5.0.0&quot; 📄 package-lock.json npm 的锁定文件，用来保证依赖版本固定。 不用管它。 📄 db.json 这是 Hexo 的“缓存数据库”。 存储： 上次生成时的文件状态 文章索引 主题资源缓存 当内容不更新时，Hexo 可以跳过部分生成过程，提高性能。 如果你出现异常，可以删除它再重新编译： hexo clean Hexo 会自动重建。 📁 .github/ 这是 GitHub workflow 用的，自动部署（CI/CD）会用到。 如果你看到它，大概率主题或 starter 模板帮你放进去的。 📄 .gitignore Git 忽略规则。 常见内容： node_modules/ public/ db.json 这些不会被上传到 GitHub。 📌 最关键的几个你需要记住的目录 按实际使用频率排序： source/ → 你写文章的地方 themes/ → 放主题 _config.yml → 配置全局设置（例如切主题） public/ → 生成后的最终网页（用来部署） scaffolds/ → 新文章模板（一般不碰） 其它都是底层设施，不需要你手动管理。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/tags/HEXO/"},{"name":"BLOG","slug":"BLOG","permalink":"http://example.com/tags/BLOG/"},{"name":"MARKDOWN","slug":"MARKDOWN","permalink":"http://example.com/tags/MARKDOWN/"}]},{"title":"PHP过滤","slug":"PHP/PHP过滤","date":"2025-11-22T12:45:31.878Z","updated":"2025-11-25T05:52:52.839Z","comments":true,"path":"2025/11/22/PHP/PHP过滤/","permalink":"http://example.com/2025/11/22/PHP/PHP%E8%BF%87%E6%BB%A4/","excerpt":"","text":"一、convert 系列（最常用） 1. convert.base64-encode 用途：读取 PHP 源码 php://filter/read=convert.base64-encode/resource=index.php 2. convert.base64-decode 用途：写入文件时用于反向解密 payload（配合 write 模式） 3. convert.quoted-printable-encode 用途：输出编码后的文本，绕某些过滤器 4. convert.quoted-printable-decode 用途：有时用于 payload 构造（较少见） 5. convert.iconv.* 把字符集转换，比如： convert.iconv.UTF-7.UTF-8 convert.iconv.utf-8.utf-16le 用途：绕字符过滤、绕黑名单 例子：UTF-7 绕过滤器，导致 payload “变相逃脱”过滤。 二、string 系列（文本转换） 6. string.rot13 用途：输出 ROT13 变换后的文本，少见但可玩 7. string.tolower 用途：把文件内容全部变成小写 例子：绕大小写过滤器 8. string.toupper 用途：同上，把内容变成大写 9. string.strip_tags 用途：移除 HTML 标签 攻击场景有限 10. string.strip 用途：去掉空格等字符 11. string.trim 用途：裁剪前后空白字符 这些在题目中 有时用于绕过滤器对关键字的匹配（特别是大小写敏感时）。 三、zlib 流系列（压缩类） 12. zlib.inflate 用途：解压 DEFLATE 13. zlib.deflate 用途：压缩成 DEFLATE 14. zlib.encode 15. zlib.decode 用途同上，某些服务器上有奇奇怪怪的文件压缩策略时可以利用 四、string.__ 多字符替换系列*（很少有人知道） 16. string.camelize 17. string.capitalize 18. string.lowercase 19. string.uppercase 这些不常用于攻击，但在绕黑名单时有奇效。 例如黑名单禁止 &quot;php&quot;，但你可以： php://filter/read=string.uppercase/resource=phP.php 把文件内容强制转换为大写，返回源码不受影响。 五、特殊或冷门但可玩性极高的过滤器 20. convert.iconv.UCS-4LE.UTF-8 用途：字符字节分离技巧 （在某些题目里可以利用多字节字符绕关键词检测） 21. convert.iconv.UTF-8.UTF-7 用途：UTF-7 常用于绕过 &lt;script&gt; 过滤或关键字过滤 在 LFI 中有时能“变形”敏感关键字 22. string.strip_low 用途：去掉 ASCII &lt;32 的字符 有时可以让 payload“洗干净” 23. string.strip_high 用途：去掉 ASCII &gt;127 的字符 常用于 Unicode 绕过攻击链 六、组合过滤器（真正的黑魔法） 过滤器可以无限连，用 | 组合： php://filter/read=string.toupper|string.rot13|convert.base64-encode/resource=index.php 你会得到： index.php → 转大写 再 rot13 最后 base64 编码输出 组合可以帮助： 绕 WAF 绕黑名单 让敏感字符变成“无害”的样子 混淆源码 躲避简单检测 七、终极必杀技：链式 filter 评论执行绕过（真正危险） 很多 CTF 里用： php://filter/string.rot13/resource=php://input 配合 POST 数据 rot13 编码后的 payload： 你就能让 PHP 执行解码后的 payload → 直接 RCE 例如 payload rot13 后变成 cevags(&quot;hello&quot;); （rot13 的 print） 传入 filter → 还原成 print → 执行。 这就是经典的 php://input RCE + filter 解码。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"过滤","slug":"过滤","permalink":"http://example.com/tags/%E8%BF%87%E6%BB%A4/"}]},{"title":"PHP支持的编码","slug":"PHP/PHP支持的编码","date":"2025-11-22T12:41:54.762Z","updated":"2025-11-22T13:16:37.828Z","comments":true,"path":"2025/11/22/PHP/PHP支持的编码/","permalink":"http://example.com/2025/11/22/PHP/PHP%E6%94%AF%E6%8C%81%E7%9A%84%E7%BC%96%E7%A0%81/","excerpt":"","text":"The following character encodings are supported in this PHP extension UTF-32BE* UTF-32LE* UTF-16* UTF-16BE* UTF-16LE* UTF-7 UTF7-IMAP UTF-8* ASCII* EUC-JP* SJIS* eucJP-win* SJIS-win* ISO-2022-JP ISO-2022-JP-MS CP932 CP51932 SJIS-mac (alias: MacJapanese) SJIS-Mobile#DOCOMO (alias: SJIS-DOCOMO) SJIS-Mobile#KDDI (alias: SJIS-KDDI) SJIS-Mobile#SOFTBANK (alias: SJIS-SOFTBANK) UTF-8-Mobile#DOCOMO (alias: UTF-8-DOCOMO) UTF-8-Mobile#KDDI-A UTF-8-Mobile#KDDI-B (alias: UTF-8-KDDI) UTF-8-Mobile#SOFTBANK (alias: UTF-8-SOFTBANK) ISO-2022-JP-MOBILE#KDDI (alias: ISO-2022-JP-KDDI) JIS JIS-ms CP50220 CP50220raw CP50221 CP50222 ISO-8859-1* ISO-8859-2* ISO-8859-3* ISO-8859-4* ISO-8859-5* ISO-8859-6* ISO-8859-7* ISO-8859-8* ISO-8859-9* ISO-8859-10* ISO-8859-13* ISO-8859-14* ISO-8859-15* ISO-8859-16* byte2be byte2le byte4be byte4le BASE64 HTML-ENTITIES (alias: HTML) 7bit 8bit EUC-CN* CP936 GB18030 HZ EUC-TW* CP950 BIG-5* EUC-KR* UHC (alias: CP949) ISO-2022-KR Windows-1251 (alias: CP1251) Windows-1252 (alias: CP1252) CP866 (alias: IBM866) KOI8-R* KOI8-U* ArmSCII-8 (alias: ArmSCII8)","categories":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"音频文件的口袋位/容器","slug":"Sundry/音频文件的口袋位_容器","date":"2025-11-22T11:40:46.604Z","updated":"2025-11-25T05:52:40.135Z","comments":true,"path":"2025/11/22/Sundry/音频文件的口袋位_容器/","permalink":"http://example.com/2025/11/22/Sundry/%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%A3%E8%A2%8B%E4%BD%8D_%E5%AE%B9%E5%99%A8/","excerpt":"","text":"概览（快速清单） MP3：private_bit（每帧 1 bit）、帧头的保留/厂商位、ID3（TXXX、COMM 等自定义帧）。 AAC（ADTS）：ADTS header 的 private bit、copyright/original 等小位；在 MP4 容器里还可用 atoms（udta/free/meta/ilst）。 WAV/RIFF：自定义 chunk（LIST/INFO/JUNK/自定义四字码），还有可用的 padding 区块。 FLAC：metadata blocks（PADDING、APPLICATION、VORBIS_COMMENT 等），可放大量数据且不改动音频帧。 Ogg/Opus/Vorbis：Vorbis comment（vendor + comments），以及容器 header 中未用字节。 MP4/M4A：atom/box（free、udta、meta、ilst 等）用于存放任意元数据；free/skip 可作隐写空间。 WMA/ASF：ASF objects（metadata objects、custom GUID/object）可以包含任意数据。 下面逐项展开，附上“为什么能隐写”、容量/可检测性、以及实操提示（如何读/写/寻找）。 1) MP3 —— private_bit 与 ID3 元数据 能藏在哪里：每个 MP3 帧头里有 1 个 private_bit（encoder 可自由使用）；另外文件开头/结尾或独立区域的 ID3v2 标签（TXXX、COMM、自定义 frame）可以存放大量文本或二进制。 为什么可用：private_bit 不影响解码；ID3 标签属于容器级元数据，播放器通常忽略其具体内容。 容量：private_bit 很小（每帧 1 bit，约 20–50 bits/s），ID3 可放数 KB 到数 MB。 检测/提取：遍历帧头读取该 bit（查找 0xFFF 同步字，解析 4 字节帧头）；读取 ID3 则用 mutagen/eyeD3/ffprobe 即可。 风险：直接修改大量 ID3 很显眼（文件大小变、标签可见），但 private_bit 更隐蔽（需专门工具解析）。 2) AAC（ADTS / MP4 封装） 能藏在哪里： ADTS header 有一个 private bit，以及若干控制位（copyright/original/home），这些位通常固定但可被利用。 当 AAC 存在于 MP4/M4A 容器中时，容器的 atoms（如 udta、free、meta、ilst）是更大的隐写区。 容量：ADTS private bit 同 MP3 每帧 1 bit；MP4 atoms 容量大（KB–MB）。 检测/提取：解析 ADTS 帧头（同步字查找），或用 mp4dump/ffprobe/AtomicParsley 查看 atoms。 3) WAV / RIFF 容器 能藏在哪里：RIFF 文件由若干 chunk 组成：fmt 、data、LIST、INFO、JUNK、自定义四字 ID chunk（fourcc）。你可以放 JUNK 或新增自定义 chunk，或者把信息放在 LIST/INFO 元数据字段。 优点：修改 chunk 不影响 PCM 数据的解码；播放器仍能正常播放。 容量：可以很大（取决于 chunk 大小），通常 KB–MB。 检测/提取：用 xxd、riffinfo、sox 或 Python 的 wave/struct 直接解析 chunk 结构查看未识别 chunk。 4) FLAC 能藏在哪里：FLAC 的 metadata block 很灵活：VORBIS_COMMENT（标签），PADDING（可保留大量空位），APPLICATION（供专用程序使用）。这些都在音频编码数据前后，不改变音频帧。 优点：标准就支持 padding 与应用块，合法且不影响解码。 检测/提取：metaflac --list 或 FLAC API 可读出各 block；PADDING 可被填充自定义数据。 5) Ogg / Vorbis / Opus 能藏在哪里：Vorbis comment（任意字段/值），以及 Ogg 页（page）头部的空字节或 vendor 字符串。Opus 在 Ogg 容器内同理。 优点：常用于标签/元数据，解析工具普遍支持。 检测/提取：vorbiscomment -l、ogginfo、或用 pyogg、mutagen 读取。 6) MP4 / M4A（箱/atom 结构） 能藏在哪里：MP4 是基于 box/atom 的层级容器。常用的隐写点：free（空白）、skip、udta（user data）、meta/ilst（iTunes 元数据），以及任意自定义 box。 优点：容量大、结构化、播放器通常忽略未知 box。 检测/提取：mp4dump/mp4box -diso/ffprobe 可列出 atoms。 7) WMA / ASF 能藏在哪里：ASF 容器的 “objects”（每个 object 有 GUID），可以存任意元数据、自定义对象或 padding。 检测/提取：用专门的 ASF/WMA 解析库查看 object 列表。","categories":[{"name":"MICS","slug":"MICS","permalink":"http://example.com/categories/MICS/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"http://example.com/tags/%E9%9A%90%E5%86%99/"}]},{"title":"Wireshark过滤语法","slug":"Sundry/Wireshark过滤语法","date":"2025-11-21T14:30:38.661Z","updated":"2025-11-25T05:52:31.788Z","comments":true,"path":"2025/11/21/Sundry/Wireshark过滤语法/","permalink":"http://example.com/2025/11/21/Sundry/Wireshark%E8%BF%87%E6%BB%A4%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1. 捕获过滤器（Capture Filter）详解 捕获过滤器作用是在抓包开始前限制抓取数据包，基于 BPF（Berkeley Packet Filter）语法。它对数据流量起“网筛”作用，过滤掉不关心的包，节省空间和性能。常用在抓包前预过滤。 1.1 基础语法结构 捕获过滤器是基于简洁的关键词和运算符，形式类似： &lt;表达式&gt; [and|or|not &lt;表达式&gt;] ... 支持的基本关键词： 1.2 逻辑运算符 and：且 or：或 not：非 示例： 抓取源 IP 是 10.0.0.1 且目标端口为 80 的 TCP 流量： src host 10.0.0.1 and tcp and dst port 80 抓取所有 UDP 包或 ICMP 包： udp or icmp 排除 ARP 包： not arp 1.3 捕获过滤器示例 2. 显示过滤器（Display Filter）详解 显示过滤器用在抓包完成后筛选数据包，功能强大、语法复杂，能针对各种协议和字段精确过滤。 2.1 语法结构 &lt;协议&gt;.&lt;字段&gt; &lt;比较符&gt; &lt;值&gt; [逻辑运算符 &lt;过滤表达式&gt;]... 2.2 常用比较符 2.3 逻辑运算符 and：且 or：或 not：非 2.4 常用协议及字段示例 2.5 示例过滤器 过滤源 IP 是 10.0.0.2 的包： ip.src == 10.0.0.2 过滤目标端口是 80 或 443 的 TCP 包： tcp.dstport == 80 or tcp.dstport == 443 过滤 HTTP GET 请求： http.request.method == &quot;GET&quot; 过滤 DNS 查询包： dns.flags.response == 0 3. 显示过滤器高级技巧 3.1 组合逻辑过滤 过滤条件可以任意组合，利用括号明确优先级，满足复杂过滤需求。 示例：过滤源 IP 是 192.168.1.1 且目标端口是 80 或 443 的 TCP 包 ip.src == 192.168.1.1 and (tcp.dstport == 80 or tcp.dstport == 443) 3.2 利用协议标志位过滤 针对 TCP 标志位的过滤非常实用，常用于诊断连接问题。 过滤 TCP SYN 包（发起连接） tcp.flags.syn == 1 and tcp.flags.ack == 0 过滤 TCP FIN 包（关闭连接） tcp.flags.fin == 1 过滤 TCP 重传包 tcp.analysis.retransmission 3.3 按报文长度过滤 有时候抓包数据量巨大，可以按包大小过滤，只看超过一定长度的包。 frame.len &gt; 1000 这可以帮你快速聚焦大数据包，比如文件传输。 3.4 过滤存在某字段的包 某些字段只有部分包有，例如 SSL 握手包中的 ssl.handshake 字段，过滤时可以用： ssl.handshake 表示只显示带有握手字段的包。 3.5 过滤 IPv6 流量 IPv6 过滤与 IPv4 类似，但字段名不同。 过滤 IPv6 源地址为 fe80::1 的包： ipv6.src == fe80::1 过滤所有 IPv6 流量： ipv6 3.6 过滤字符串字段包含关系 常用 HTTP 或 DNS 过滤，查找域名或 URL 包含某关键字。 HTTP Host 中包含 google： http.host contains &quot;google&quot; DNS 查询名匹配某正则表达式（如所有以.com 结尾）： dns.qry.name matches &quot;.*\\.com&quot; 4. 捕获过滤器实用技巧和复杂表达式 4.1 捕获时指定多个条件 要捕获多个 IP 或端口流量时，用括号明确优先级。 示例：抓取目的 IP 是 192.168.1.1 或 192.168.1.2 的 TCP 包 tcp and (dst host 192.168.1.1 or dst host 192.168.1.2) 4.2 排除特定协议 想抓包排除 ARP 包： not arp 想抓取非 TCP 包： not tcp 4.3 指定网卡的捕获过滤器 用-i 参数指定抓哪个接口，结合过滤器精确抓包： tcpdump -i eth0 tcp port 80 4.4 捕获过滤器语法限制 捕获过滤器不支持协议内部字段，只能针对包头基本字段（IP、端口、协议），不支持显示过滤器的复杂条件。 6. 显示过滤器更详细字段解析 6.1 以太网层（Ethernet） eth.src：源 MAC 地址 eth.dst：目的 MAC 地址 eth.type：以太网类型，如 0x0800 表示 IPv4，0x86DD 表示 IPv6 6.2 IP 层 ip.version：IP 协议版本，4 或 6 ip.ttl：生存时间（TTL） ip.id：标识，用于分片识别 ip.proto：承载协议类型，如 6 是 TCP，17 是 UDP ip.flags：分片标志 ip.frag_offset：分片偏移 示例过滤 TTL 小于 64 的包： ip.ttl &lt; 64 6.3 TCP 层 tcp.seq：序列号 tcp.ack：确认号 tcp.flags：标志位整体 tcp.flags.syn：同步标志 tcp.flags.ack：确认标志 tcp.flags.fin：关闭连接标志 tcp.window_size：窗口大小 过滤 TCP 窗口大小小于 1024 的包： tcp.window_size &lt; 1024 6.4 UDP 层 udp.length：UDP 报文长度 6.5 ICMP 层 icmp.type：类型码（如 8 是 Echo 请求，0 是 Echo 应答） icmp.code：类型细分 过滤 ICMP Echo 请求包： icmp.type == 8 6.6 HTTP 协议 http.request.method：请求方法（GET、POST、PUT 等） http.response.code：响应码（200、404 等） http.host：请求的主机名 http.user_agent：客户端信息 过滤 HTTP 响应码 404： http.response.code == 404 6.7 DNS 协议 dns.qry.name：查询域名 dns.qry.type：查询类型（A、AAAA、MX 等） dns.a：A 记录返回 IP 地址 dns.flags.response：0 表示请求，1 表示响应 过滤所有 DNS 查询包： dns.flags.response == 0 6.8 SSL/TLS 协议 ssl.handshake.type：握手类型（客户端 Hello、服务端 Hello 等） ssl.record.version：协议版本 ssl.record.length：记录长度 过滤所有 TLS 客户端 Hello 包： ssl.handshake.type == 1 7. 显示过滤器性能优化建议 当抓包文件巨大时，复杂过滤语法可能会导致 Wireshark 卡顿甚至崩溃。以下建议帮你提升效率： 尽量先用捕获过滤器减少抓包量 过滤表达式中避免使用 contains 和 matches 这类正则匹配，性能消耗大 尽量使用字段的等值或范围比较 对 IP 和端口的过滤尽量集中，不要写太多 or 条件 使用括号明确运算顺序，避免解析错误 分步骤过滤，先用粗过滤，再逐步精细化 8. 实用场景举例 8.1 定位特定主机通信 只看某台主机的所有流量： ip.addr == 192.168.1.100 8.2 诊断 TCP 三次握手过程 过滤 TCP SYN 包： tcp.flags.syn == 1 and tcp.flags.ack == 0 过滤 TCP SYN+ACK 包： tcp.flags.syn == 1 and tcp.flags.ack == 1 过滤完成三次握手的包： tcp.flags.ack == 1 and tcp.seq == tcp.ack - 1 8.3 抓取 HTTP 请求 过滤所有 HTTP 请求： http.request 过滤 POST 请求： http.request.method == &quot;POST&quot; 8.4 DNS 问题排查 过滤 DNS 请求： dns.flags.response == 0 过滤 DNS 响应： dns.flags.response == 1 过滤查询失败的 DNS 响应（RCODE 不为 0）： dns.flags.rcode != 0 8.5 网络攻击检测 过滤 ICMP 洪泛攻击（大量 ICMP 请求）： icmp.type == 8 过滤 TCP SYN 洪泛攻击： tcp.flags.syn == 1 and tcp.flags.ack == 0 9. 捕获过滤器更丰富的使用场景 9.1 按接口过滤 指定接口抓包： tcpdump -i eth1 监听所有接口： tcpdump -i any 9.2 指定 MAC 地址抓包 抓取源 MAC 地址是 00:11:22:33:44:55 的包： ether src 00:11:22:33:44:55 目的 MAC 地址： ether dst 00:11:22:33:44:55 9.3 抓特定协议 抓取 HTTP 流量（通常端口 80 端口）： tcp port 80 抓取 DNS 流量： udp port 53 抓取所有 ARP 包： arp 9.4 按包大小过滤 抓包长度大于 1000 字节的包： greater 1000 9.5 复杂组合示例 抓取目标是 192.168.1.10 且 TCP 端口是 22 或 80 的包： dst host 192.168.1.10 and tcp and (dst port 22 or dst port 80) 抓取除 ICMP 外所有流量： not icmp 10. 显示过滤器高级语法技巧 10.1 字段赋值判断 某些协议中字段可判断是否存在或赋值。 判断 HTTP 请求是否有 Host 头： http.host 判断 DNS 查询名是否以某域名结尾（正则）： dns.qry.name matches &quot;.*\\.cn$&quot; 10.2 多字段范围过滤 过滤 TCP 目的端口是 1024 到 65535 的包（高端口）： tcp.dstport &gt;= 1024 and tcp.dstport &lt;= 65535 10.3 空值判断 过滤没有 TCP 选项的包： !tcp.options 10.4 按协议层级过滤 过滤所有包含 HTTP 但排除 HTTPS 的包： http and not ssl 10.5 显示过滤器变量 Wireshark 支持变量绑定和条件过滤，可在高级脚本和命令行用法中发挥作用，这里不做深讲。 11. 捕获过滤器 vs 显示过滤器 12. 常用命令参数总结 -i &lt;interface&gt;：指定接口 -c &lt;count&gt;：抓包数量限制 -s &lt;snaplen&gt;：抓包长度限制 -w &lt;file&gt;：写入文件 -r &lt;file&gt;：读取文件分析 -n：禁止DNS解析，直接显示IP -v：详细模式 -e：显示链路层头部信息","categories":[{"name":"Wireshark","slug":"Wireshark","permalink":"http://example.com/categories/Wireshark/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"过滤","slug":"过滤","permalink":"http://example.com/tags/%E8%BF%87%E6%BB%A4/"}]},{"title":"Hello","slug":"hello-world","date":"2025-11-21T14:22:12.448Z","updated":"2025-11-21T14:22:12.449Z","comments":true,"path":"2025/11/21/hello-world/","permalink":"http://example.com/2025/11/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"KALI小知识点","slug":"KALI/KALI小知识点","date":"2025-11-21T12:47:45.412Z","updated":"2025-11-25T05:53:01.798Z","comments":true,"path":"2025/11/21/KALI/KALI小知识点/","permalink":"http://example.com/2025/11/21/KALI/KALI%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"🧩 一、文件属性查看 目的：发现最基本的线索。 🔧 常用方式 file image.jpg exiftool image.jpg strings image.jpg | less 📘 作用 file：查看文件真实格式（有时文件扩展名被伪装）。 exiftool：读取 EXIF 元数据，常用于 JPEG、PNG。可发现隐藏信息、作者、GPS、注释等。 strings：提取文件中的可打印字符串，有时能直接看到 flag 或提示。 🧠 小技巧 有时 flag 会藏在 EXIF 的 Comment 或 UserComment 字段。 伪装格式的情况要重点查：比如 .jpg 实际上是 .zip。 🧮 二、zsteg 用于分析 PNG、BMP 等无损图片的像素隐写。 🔧 使用方法 zsteg image.png zsteg -a image.png 📘 作用 自动检测 LSB（最低有效位）隐写。 可分析隐藏在每个颜色通道（R、G、B、Alpha）的二进制信息。 能识别隐藏文本、ZIP、PNG、base64 等。 🧠 小技巧 zsteg -a 是自动模式，检查所有常见隐写方式。 如果是 PNG 文件 且 zsteg 没发现，说明可能不是像素隐写。 🪞bit-plane 一张图片的每个像素（Pixel）由几个通道组成，比如： RGB 三通道（Red、Green、Blue） 每个通道通常是 8 位（bit），即取值范围 0–255。 每个像素的二进制位，可以按位拆成 8 个“平面”： 第 1 位平面（bit 7）：最高位（Most Significant Bit，MSB） 第 8 位平面（bit 0）：最低位（Least Significant Bit，LSB） 高位平面 (bit7-bit4)：决定图片主要明暗、颜色信息。 低位平面 (bit3-bit0)：变化较小，人眼不敏感 → 常被用来藏信息。 👉 LSB 位平面（特别是 bit0 或 bit1） 经常能看到隐藏的信息，例如： 隐藏文字（例如 flag、二维码） 隐藏图形、logo、另一张图片轮廓 因为隐写常常修改 LSB 位，人眼几乎看不出变化，但提取出来时很明显。 🔍 三、binwalk 主要分析文件结构、分离隐藏文件。 🔧 使用方法 binwalk image.jpg binwalk -e image.jpg # 自动提取嵌入文件 📘 作用 检测是否在图片中嵌入了其他文件（例如 ZIP、RAR、PNG、MP3 等）。 可提取嵌套文件（如“图片中藏压缩包”）。 🧠 小技巧 如果 binwalk 提取出了 .zip、.rar、.txt 文件，要继续递归分析。 xxd 或 hexdump 可辅助查看十六进制结构。 🧰 四、outguess 针对 JPEG 图片的隐写分析工具。 🔧 使用方法 outguess -r image.jpg output.txt （如果知道密码，可以加 -k &quot;password&quot;） 📘 作用 从 JPEG 图像中提取由 OutGuess 工具隐藏的信息。 是 CTF JPEG 隐写的常用检查工具。 🧠 小技巧 通常只对 JPEG 格式 有效。 如果 outguess 没结果，可以试 steghide。 🎨 五、stegsolve 图像可视化分析工具（图形界面）。 🔧 启动方式 java -jar StegSolve.jar 📘 作用 可查看图像的每个颜色通道（R/G/B/A）及其组合。 可检测 LSB 隐写（通过 bit plane）。 可通过“Analyze → File Format”检查尾部额外数据。 🧠 小技巧 打开后可以逐个切换通道查看隐藏文字或二维码。 “Frame Browser”可用于查看多帧 GIF。 设置 kali 中文 编辑 /root/.profile 文件（部分按照网上教程设置中文后不生效，就是因为没有设置这一步） #修改前 LANG=C LANGUAGE=C #修改后 LANG=zh_CN.UTF-8 LANGUAGE=zh_CN:zh pip 与 pipx pip 是 Python 的默认包管理工具，用来安装、升级、卸载 Python 包。 pipx 是一个专门用于安装和运行 Python 命令行工具（CLI 应用） 的工具。 它的主要作用是： 让每个独立的命令行工具都安装在各自的隔离虚拟环境中，互不干扰。 要删除使用 pipx 安装的软件包，请使用 pipx uninstall package_name 命令。 kali 默认字典位置 kali 默认字典位置 dirb -&gt; /usr/share/dirb/wordlists dirbuster -&gt; /usr/share/dirbuster/wordlists dnsmap.txt -&gt; /usr/share/dnsmap/wordlist_TLAs.txt fasttrack.txt -&gt; /usr/share/set/src/fasttrack/wordlist.txt fern-wifi -&gt; /usr/share/fern-wifi-cracker/extras/wordlists john.lst -&gt; /usr/share/john/password.lst legion -&gt; /usr/share/legion/wordlists metasploit -&gt; /usr/share/metasploit-framework/data/wordlists nmap.lst -&gt; /usr/share/nmap/nselib/data/passwords.lstrockyou.txt sqlmap.txt -&gt; /usr/share/sqlmap/data/txt/wordlist.txt wfuzz -&gt; /usr/share/wfuzz/wordlist wifite.txt -&gt; /usr/share/dict/wordlist-probable.txt 常见字典： 枚举 CGI 服务 路径: ./seclists/Discovery/Web_Content/cgis.txt 用途: 用于枚举 Web 应用中的 CGI 脚本。 路径枚举大字典 路径: ./seclists/Discovery/Web_Content/directory-list-2.3-medium.txt 用途: 用于路径枚举，较为全面，是 HackTheBox 和 OSCP 常用的大字典。 常见目录字典 路径: /usr/share/dirb/wordlists/common.txt /usr/share/seclists/Discovery/Web_Content/common.txt /usr/share/seclists/Discovery/Web_Content/raft-medium-directories-lowercase.txt 用途: 这些字典适用于常见目录的枚举，帮助发现常见的 Web 应用目录和文件。 扩展名字典 路径: /usr/share/seclists/Discovery/Web_Content/raft-large-extensions.txt 用途: 用于枚举常见的文件扩展名，帮助识别网站中可能存在的文件类型。 Fuzzing 字典 路径: /usr/share/seclists/Fuzzing/alphanum-case-extra.txt /usr/share/seclists/Fuzzing/special-chars.txt 用途: 用于 fuzz 测试时输入特殊字符，查找可能的漏洞。 LFI 漏洞字典 路径: /usr/share/seclists/Fuzzing/LFI/LFI-gracefulsecurity-linux.txt 用途: 专门用于本地文件包含（LFI）漏洞的测试，帮助渗透测试人员检查目标系统是否存在文件包含漏洞。","categories":[{"name":"KALI","slug":"KALI","permalink":"http://example.com/categories/KALI/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"http://example.com/tags/%E9%9A%90%E5%86%99/"},{"name":"dict","slug":"dict","permalink":"http://example.com/tags/dict/"}]},{"title":"Kali常用命令分类","slug":"KALI/kali常用命令","date":"2025-11-21T12:40:58.981Z","updated":"2025-11-23T04:51:39.675Z","comments":true,"path":"2025/11/21/KALI/kali常用命令/","permalink":"http://example.com/2025/11/21/KALI/kali%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"文件系统命令 ls - 列出目录内容 cd - 切换目录 pwd - 显示当前目录 cp - 复制文件或目录 mv - 移动或重命名文件或目录 rm - 删除文件或目录 touch - 创建空文件或修改文件时间 mkdir - 创建目录 rmdir - 删除空目录 find - 在目录树中查找文件 文件权限和属性 chmod - 改变文件权限 chown - 改变文件所有者 chgrp - 改变文件所属组 lsattr - 显示文件属性 setfacl - 设置文件访问控制列表 getfacl - 获取文件访问控制列表 文件内容查看和编辑 cat - 查看文件内容 less - 分页查看文件内容 more - 分页查看文件内容 head - 显示文件头部内容 tail - 显示文件尾部内容 grep - 在文件中搜索文本 sed - 文本替换和编辑 awk - 文本处理工具 网络工具 ping - 检测网络连通性 traceroute - 显示数据包到达目标主机所经过的路径 nslookup - 查询域名信息 whois - 查询域名注册信息 ifconfig - 显示网络接口配置 netstat - 显示网络连接、路由表、接口统计信息 tcpdump - 抓取网络数据包 wireshark - 网络协议分析工具（图形界面） 系统管理 useradd - 创建用户 userdel - 删除用户 passwd - 设置用户密码 sudo - 以超级用户权限执行命令 apt-get - 安装、升级、删除软件包 dpkg - Debian 软件包管理工具 service - 管理系统服务 systemctl - 系统和服务管理工具 密码破解 john - 密码破解工具 hydra - 暴力破解工具 medusa - 多协议暴力破解工具 ncrack - 密码破解工具 信息收集 whoami - 显示当前用户 id - 显示用户和组信息 last - 显示用户登录记录 lastb - 显示失败的登录尝试 ps - 显示当前进程 top - 显示系统进程和资源使用情况 htop - 进程查看和管理工具（图形界面） lsof - 列出打开的文件和进程 其他 echo - 输出文本到控制台 date - 显示或设置日期和时间 cal - 显示日历 bc - 命令行计算器 man - 显示命令手册页 info - 显示信息文档 which - 显示命令所在路径 whereis - 查找二进制文件、源代码和手册页 系统信息 arch显示机器的处理器架构 name -m 显示机器的处理器架构 name -r 显示正在使用的内核版本 dmidecode -q显示硬件系统部件 -(SMBIOS/DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试读取操作 cat/proc/cpuinfo 显示 CPU info 的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些 swap 被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示 2007 年的日历表 date .00 设置日期和时间 -月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机（系统的关机、重启以及登出） shutdown -h now 关闭系统 init 0 关闭系统 telinit 0关闭系统 shutdown -h hours:minutes &amp; 按预订时间关闭系统 shutdown -c 取消按预订时间关闭系统 shutdown -r now 重启 reoot 重启 logout 注销 文件和目录 cd /home 进入'/home' 目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构 lstree 显卡文件和目录由根目录开始的树形结构 mkdir dir1 创建一个叫做'dir1'的目录' mkdir dir1 dir2 同时创建两个目录 mkdir dir1/dir2 创建一个目录树 rm -f file1 删除一个叫'file1'的文件 rmdir dir1 删除一个叫‘dir1’的目录 rm -rf dir1 删除一个叫‘dir1’的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动一个目录 cp file1 file2 复制一个文件 cp dir/*. 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1. 复制一个目录到当前工作目录 cp -a /tmp/dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳-(YYMMDDhhmm) iconv -l 列出已知的编码 文件搜索 find /-name file1 从‘/’开始进入根文件系统搜索文件和目录 find /-user user1 搜索属于用户‘user1’的文件和目录 find /home/user1 -name \\*.bin 在目录‘/homi/user1 ’中搜索带有‘ bin’结尾的文件 find /usr/bin -type f -atime +100 搜索在过去 100 天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在 10 天内被创建或者修改过的文件 find /-name \\*.rpm -exec chmod 755'{}'\\; 搜素以‘.rpm’结尾的文件并定义其权限 find /-xdev -name \\*.rpm 搜索以‘.rpm’结尾的文件，忽略光驱、键盘等可移动设备 locate \\*.ps 寻找以‘.ps’结尾的文件 -先运行‘updatedb ’命令 whereis halt 显示一个二进制文件、源码或 man 的位置 挂载一个文件系统 mount /dev/hda2/mnt/hda2 挂载一个叫 hda2 的盘-确定目录‘/mnt/hda2 ’已经存在 umount /dev/hda2 卸载一个叫做 hda2 的盘 -先从挂载点‘/mnt/hda2 ’退出 fuser -km /mnt/da2 当前设置繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入/etc/mtab 文件-当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个 cdrom 或 dvdrom mount /dev /hdc /mnt/cdrecorder 挂载一个 cdrw 或 dvdrom mount -o loop /mnt/cdrom 挂载一个文件或 ISO 镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个 windows FAT32 文件系统 mount /dev/sda1 /mnt/usdisk 挂载一个 usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个 windows 网路共享 磁盘空间 df -h 显示已挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录‘dir1’已经使用的磁盘空间 du -sk * | sort -rm 以容量大小为依据次显示文件和目录的大小 rpm -q -a --qf '%10{SIZE}n' | sort -kl,1n 以大小为依据次显示已安装的 rpm 包所使用的空间 (fedora, redhat 类系统） dpkg-query -W -f='${Installed-Size;10}t${Package}n' |sort -k1,1n 以大小为依据显示已安装的 deb 包所使用的空间（ubuntu,debian 类系统） 用户和群组 groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname&quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于“admin”用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户（‘ -r’排除主目录） 文件的权限-使用“+”设置权限，使用“ -”用于取消 ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成 5 栏显示 chmod ugo+rwx directory1 设置目录的所有人（ u）、群组（g）以及其他人（o）以读（r）、写（w）和执行（x）的权限 chmod go-rwx directory1 删除群组（g）与其他人（o）对目录的读写执行权限 chmown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有让人属性并同时改变目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find /-perm -u+s 罗列一个系统中所有使用了 SUID 控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位-与性该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID 位 chmod g+s /home/public 设置一个目录的 SGID 位-类似 SUID，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位-只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性-使用“+”设置权限，使用“ -”用于取消 chattr +a file1 只允许追加方式写文件 chatr +c file1 允许这个文件能被内核自动压缩 /解压 chattr +d file1 在运行文件系统备份时， dump 程序将忽略这个文件 chattr +i file1 设置成不可改变的文件， 不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lattr 显示特殊的属性 打包和压缩文件 bunzip2解压一个叫做‘’的文件 bzip2 file1 压缩一个叫做‘file1’的文件 gunzip解压一个叫做‘’的文件 gzip file1 压缩以额叫做‘ file1’的文件 gzip -9 file1 最大程度压缩 rar a test_file 创建一个叫做‘’的包 rar a file1 file2 dir1 同时压缩‘file1’，‘file2’以及目录‘dir1’ rar x 解压 rar 包 unuar x 解压 rar 包 tar -cvf archive.tar file1 创建一个非压缩的 tarbal1 tar -cvf archive.tar file1 file2 dir1 创建一个包含了‘file1’，‘file2’以及‘dir1’的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到/tmp 目录下 tar -cvfj archive.tar.bz2 dir1 创建一个 bzip2 格式的压缩包 tar -xvfj archive.tar.bz2 解压一个 bzip2 格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个 gzip 格式的压缩包 tar -xvfz archive.tar.gz 解压一个 gzip 格式的压缩包 zip file1 创建一个 zip 格式的压缩包 zip -r file1 file2 dir1 将几个文件和目录同时压缩成一个 zip 格式的压缩包 unzip 解压一个 zip 格式压缩包 RPM 包-（Fedora,Redhat 及类似系统） rpm -ivh package.rpm 安装一个 rpm 包 rpm -ivh --nodeeps package.rpm 安装一个 prm 包而忽略依赖关系警告 rpm -U package.rpm 更新一个 rpm 包但不改变其配置文件 rpm -F package.rpm 更新一个确定已安装的 rpm 包 rpm -e package_name.rpm 删除一个 rpm 包 rpm -qa 显示系统中所有已安装的 rpm 包 rpm -qa | grep httpd 显示所有名称中包含“ httpd”字样的 rpm 包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的 rpm 包 rpm -ql package_name 显示已经安装的 rpm 包提供的文件列表 rpm -qc package_name 显示一个已经安装的 rpm 包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个 rpm 包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个 rpm 包所占的体积 rpm -q package_name --scripts 显示在按钻根/删除期间所执行的脚本 rpm -q package_name --changelog 显示一个 rpm 包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个 rpm 包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的 rpm 包提供的文件列表 rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rmp --checksig package.rpm 确认一个 rpm 包的完整性 rpm -qa gpg-pubkey 确认已安装所有 rpm 包的完整性 rpm -V package_name 检查文件尺寸、许可、类型、所有者、群组、MD5 检查以及最后修改时间 rpm -Va 检查系统中所有已安装的 rpm 包-小心使用 rpm -Vp package.rpm 确认一个 rpm 包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个 rpm 包运行可执行文件 rpm -ivh /usr/src/redhat/RMS/arch /package.rpm 从一个 rpm 源码安装一个构建好的包 rpmbuild --reuild package_name.src.rpm 从一个 rpm 源码构建一个 rpm 包 YUM 软件包升级器 -（Fedora,RedHat 及类似系统） yum install package_name 下载并安装一个 rpm 包 yum localinstall package_name.rpm 将安装一个 rpm 包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有的 rpm 包 yum update package_name 更型一个 rpm 包 yum remove package_name 删除一个 rpm 包 yum list 列出当前系统中安装的所有包 yum search package_name 在 rpm 仓库中搜寻软件包 yum clean packages 清理 rpm 缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包（Debian,Ubuntu 及类似系统） dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含“ httpd”字样的 deb 包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个 deb 包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个 deb 包提供 APT 软件工具（ Debian,Ubuntu 及类似系统） apt-get intall package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个 deb 包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searmhed-package 返回包含所要搜索字符串的软件包名称 查看文件内容 cat file1 从第个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件内容 more file1 查看一个文件的内容 less file1 类似与‘more’命令，但时它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 `tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中大的内容 文本处理 cat file1 | command( sed, grep, awk, grep,et...) &gt;result.txt 合并一个文件的详细说明文本， 并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep,etc...) &gt;&gt;resulttxt 合并一个文件的详细说明文本， 并将简介写入一个已有的文件夹中 grep Aug /var/log/messages 在文件‘/var/log/massages ’中查找关键词“ Aug” grep ^Aug /var/log/messages 在文件‘/var/log/messages ’中查找以“Aug”开始的词汇 grep [0-9] /var/og/messages 选择‘/var/log/messages ’文件中所包含数字的行 grep Aug -R /var/log/* 在目录‘/var/log ’及随后的目录中搜索字符串“ Aug” sed 's/stringa1/stringa2/g' example.txt 将 example.txt 文件中的“string1”替换成“string2” sed '/^$/d' example.txt 从 example.txt 文件中删除所有空白行 sed '/*#/d; /^$/d' example.txt 从 example.txt 文件中删除所有注释和空白行 echo 'esempio' |tr '[:lower:]' '[:upper:]' 合并上下单元格内容 sed -e 'ld' result.txt 从文件 example.txt 中排除第一行 sed -n '/stringal/p' 查看只包含词汇“ string1”的行 sed -e 's/*$//' example.txt 删除每一行最后的看空白字符 sed -e 's/stringal//g' example.tst 从文档中只删除词汇“stringl”并保留剩余全部 sed -n '1,5p;5q' example.txt 查看从第一行到第 5 行内容 sed -n '5p;5q' example.txt 查看第 5 行 sed -e 's/00*/0/g' example.txt 用单个零替换多个零 cat -n file1 表示文件的行数 cat example.txt | awk 'NR%2==1' 删除 example.txt 文件中的所有偶数行 echo a b c | awk'{ print $1}' 查看一行第一栏 echo a b c | awk ' {print $1,$3}' 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容，中间用“+”区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集（重复的行只保留一份） sort file1 file2 |uniq -u 删除交集，留下其他的行 sort file1 file2 |uniq -d 取出两个文件的交集（只留下同时存在于两个文件中的文件） comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换 dos2unix 将一个文本文件的格式从 MSDOS 转换成 UNIX unix2dos 将一个文本文件的格式从 UNIX 转换成 MSDOS recode ..HTML&lt;page.tt &gt;page.html 将一个文本文件转换成 html recode -l |more 显示所有允许的转换格式文件系统分析 badblocks -v /dev/hdal 检查磁盘 hdal 上的坏次块 fsck /dev/hdal 修复/检查 hdal 磁盘上 linux 文件系统的完整性 fsck.ext2 /dev/hdal 修复/检查 hdal 磁盘上 ext2 文件系统的完整性 e2fsck /dev/hdal 修复/检查 hdal 磁盘上的 ext2 文件系统的完整性 e2fsck -j /dev/hdal 修复/检查 hdal 磁盘上 ext3 文件系统的完整性 fsck ext3 /dev/hkal 修复/检查 hdal 磁盘上 ext3 文件系统的完整性 fsck .vfat /dev/hdal 修复/检查 hdal 磁盘上 fat 文件系统的完整性 fscm .msdos /dev/hdal 修复/检查 hdal 磁盘上 dos 文件系统的完整性 dosfsck /dev/hdal 修复/检查 hdal 磁盘上 dos 文件系统的完整性 初始化一个文件系统 mkfs /dev/hdal 在 hdal 分区创建一个文件系统 mke2fs /dev/hdal 在分区创建一个 linux ext2 的文件系统 mke2fs -j /dev /hdal 在 hdal 分区创建一个 linux ext3(日志型）的文件系统 mkfs -t vfat 32 -F /dev/hdal 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mks 创建一个 swap 文件 SWAP 文件系统 mks 创建一个 swap 文件系统 swapon /dev/hda3 启用一个新的 swap 文件系统 swapon /dev/hda2 /dev/hdb3 启用两个 swap 分区备份 dump -0aj -f /tmp/home0.bak /home 制作一个‘/home’目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个‘/home’目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav --delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过 SSH 通道 rsync rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过 ssh 和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过 ssh 和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of+hda.gz' 通过 ssh 在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf dackup.tar /home/user 执行一次对‘/home/user' 目录的交互式备份操作 ( cd /tmp/local/&amp;&amp; tar c. ) | ssh -C user@ip_addr 'cd /home/share/ &amp;&amp; tar x -p' 通过 ssh 在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr ' cd /home/backup-home &amp;&amp; tar x -p' 通过 ssh 在远程目录中复制一个本地目录 tar vf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name '*.txt' | xargs cp -av --target-directory=home/backup/ --parents 从一个目录查找并复制所有以‘ .txt’结尾的文件到另一个目录 find /var/log -name '*.log' |tar cv -- \\ bzip2 &gt; log.tar.bz2 查找所有以‘.log’结尾的文件并做成一个 bzip 包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR(Master Boot Record) 内容复制到软盘的动作大的 i=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复 MBR 内容 光盘 cdrecord -v gracetime=2 dev=/dev/cdrom -ejectlank=fast -force 请看空一个可复写的光盘内容 mkisofs /dev/cdrom &gt;cd.iso 再磁盘上创建一个光盘的 iso 镜像文件 mkisofs /dev/cdrom | gzip &gt;cd_iso.gz 在磁盘上创建一个压缩了的光盘 iso 镜像文件 mkisofs -J -allow-leading-dots -R -V&quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的 iso 镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个 ISO 镜像文件 gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom 刻录一个压缩了的 ISO 镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个 ISO 镜像文件 cd-paramia -B 从一个 CD 光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别 scsi 通道 dd if=/dev/hdc |md5sum 校验一个设备的 md5sum 编码，例如一张 CD 应用命令 whois 域名/ip 查看域名的详细信息 ping 域名/ip 测试本机到远端主机是否联通 dig 域名/ip 查看域名解析的详细信息 host -l 域名 dns 服务器传输 zone 扫描 nmap: -sS 半开扫描 TCP 和 SYN 扫描 -sT 完全 TCP 链接扫描 -sU UDP 扫描 -PS sym 包探测（防火墙探测） -PA ack 包探测 （防火墙探测） -PN 不 ping -n 不 dns 解析 -O 操作系统识别 -sV 服务器版本信息(banner) -P 端口扫描 -T 设置时间级别（ 0-5） -iL 导入扫描将结果 -oG 输出扫描结果 操作系统识别： p0f -i eth0 -U -p 开启混杂模式 xprobe2 ip 域名检测 os banner 获取： nc ip port 检测端口是否打开 telnet ip port 检测端口是否打开 wget ip 下载主页 cat index.html | more 是否显示主页代码 q 推出 windows 枚举 nmap -sS -p 139,445 ip 扫描 windows smbgetserverinfo -i targetIP 扫描 name,os,组 smbdumpusers -i targetIP 列出用户 smbclient -L //targetIP 列出共性 使用 windows ： net use \\\\ipipc$&quot;&quot; /u:&quot;&quot; 开启看空会话 net view \\\\ip 显示共享信息 smbclient: smbclient -L hostName -I targetIP 枚举共享 smbclient -L hostName/share -U &quot;&quot; 用看空用户链接 smbclient -L hostName -I targetIP -u admin 普通用户链接 rpcclient: rpcclient targetIP -u &quot;&quot; 打开一个空会话 netshareenum 枚举共享 enumdomusers 枚举用户 lsaenumsid 枚举域 SID queryuser RID 查询用户信息 createdomuser 创建用户访问","categories":[{"name":"Kali","slug":"Kali","permalink":"http://example.com/categories/Kali/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"搭建自己的非公开博客","slug":"博客搭建/搭建自己的非公开博客","date":"2025-11-19T13:54:23.389Z","updated":"2025-11-23T13:06:40.333Z","comments":true,"path":"2025/11/19/博客搭建/搭建自己的非公开博客/","permalink":"http://example.com/2025/11/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%9E%E5%85%AC%E5%BC%80%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"VScode(开发环境) 针对于编写现代 Web 和云应用的跨平台源代码编辑器，可在桌面上运行，并且可用于 Windows，macOS 和 Linux。 Hexo（框架） Hexo 是一个快速、简单且功能强大的博客框架。你用 Markdown（或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。 本地环境 Git Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 注意配置 Git 环境 右键--显示更多--Open Bash here Git Bash • 任何 Git 子命令都能用 • 支持高级参数（--patch、--rebase-merges、--squash 等） • 能处理复杂脚本/自动化 • 适合 CTF / DevOps / 深度开发 GUI • 看得见历史和差异 • 更适合初学者和简单日常操作 • 复杂 rebase、工作树脚本、submodule 管理能力有限 node.js 一句话定位： 一个让 JavaScript 脱离浏览器、跑在操作系统上的运行环境。 它包含两部分： V8 引擎：负责执行 JS 代码（来自 Chrome） Node API：负责提供系统能力 - 文件读写（fs） - 网络（http/net） - 子进程（child_process） - 异步事件循环（event loop） 安装 HEXO 使用 CMD，命令行输入 npm install -g hexo-cli 安装 hexo 框架 创建自己的 MyBlog 文件夹（注意文件夹内部一定要空的，不然后续可能报错） 在自己的文件夹下右击，打开open git bash here输入命令安装（默认位置即可，方面后续配置，不建议修改） 输入 hexo init 给你自动搭一个完整的博客项目骨架，本质就是 初始化一个 Hexo 项目目录，让你不用手动创建文件夹、配置文件和依赖。 这一句代码其实包含了以下手动三步骤 ① 创建 Hexo 的标准目录结构 它会生成像下面这样的目录： myblog/ ├─ \\_config.yml # 项目配置 ├─ package.json # Node 依赖说明 ├─ source/ # 文章放这里 ├─ themes/ # 主题目录 ├─ scaffolds/ # 新建文章的模板 └─ node_modules/ # （后面由 npm 自动填充） 这是一个完整的 Hexo 博客项目框架。 ② 从 Hexo 官方仓库拉模板 实际上 Hexo init 背后做的事情类似： git clone https://github.com/hexojs/hexo-starter.git 但你无需手动 clone，Hexo 会自动处理好 starter 模板。 ③ 自动安装依赖（npm install） Hexo 会在新项目目录里跑： npm install 装好运行 Hexo 所需要的 Node 模块，比如： hexo hexo-cli hexo-renderer-ejs hexo-server hexo-generator-index 等等 这步很关键，否则你没法 hexo g / hexo s。 之后 MyBlog 会下载很多文件 右击---Open Git Bash here---输入 hexo -v 验证 Hexo 是否安装正常 输入 hero s 在你的浏览器中打开 http://localhost:4000/，就可以看到以下页面 报错解决方式 如果你使用 Windows PowerShell，应该会报错，如果使用 CMD，那就不会报错了。 那我一定要使用 Windows PowerShell，怎么办？ 包有解决办法的。 短期（ 只对当前窗口生效） Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass 长期有效（ 允许当前用户执行脚本） Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned 然后再输入 hexo s ，就可以成功了 若你不在 MyBlog 文件夹下，也会报错。 安装/卸载插件，请在 MyBlog 根目录下操作，就是在 MyBlog 中执行 markdown-it 配置文件格式错了？ YAML 要对齐，有缩进错误时 Hexo 直接报错或不渲染。改动后先 hexo clean 再跑。 网页中导航栏无法固定？ 首先是给 main.css 文件的 .navbar 添加属性 position: fixed; 看看成功没。 如果还是没成功，可能是被其他 CSS 文件或样式覆盖。 直接在里面在添加一句 position: fixed !important; 要是还是不行，请把 .navbar 样式全部移到 main.css 文件的底部。 安装个性化主题 主题安装 打开 hexo 的主题官网Themes 下载自己喜欢的主题，我这边选择了hexo-theme-Klise-enhanced 他的主页也有一些安装步骤 你需要下载一个字数统计插件: npm install hexo-wordcount --save 安装主题文件 git clone https://github.com/g0dmao/hexo-theme-Klise-enhanced.git 将主题根目录的_config.hexo-theme-Klise-enhanced.yml 移动到博客根目录。你可以打开该文件进行主题的一些配置。 下面图片已经移动后的样子，就是再 MyBlog 文件夹中 在博客配置文件_config.yml（根目录）中启用主题。 打开主题文件夹下的 source\\css\\main.css 在头部修改，可以自定义明暗模式下不同的背景，已做好注释。 打开主题文件夹下的 layout\\layout.ejs 修改 document.title 即可。 document.addEventListener('visibilitychange', function () &#123; if (document.visibilityState == 'hidden') &#123; normal_title = document.title; document.title = '点一下'; &#125; else document.title = normal_title; &#125;); 安装三个插件 （可选） Hexo 插件都是 npm 包，直接安装即可。 (1) 安装 markdown-it 渲染器 先卸载默认 renderer（可选，但推荐，避免冲突）： npm uninstall hexo-renderer-marked 安装 markdown-it 渲染器： npm install hexo-renderer-markdown-it-plus --save 然后在你的 Hexo 全局配置 _config.yml 中加入 markdown-it 配置（推荐项）： markdown: preset: default render: html: true plugins: - markdown-it-container 不加这些插件也能跑，只是体验没那么好。 是不是发现复制上去的代码报错了，咱们接着解决，在根目录创建 hexo-schema.json， Hexo JSON Schema 并不是 Hexo 系统内部的东西，而是给 VS Code / 编辑器 用的配套“智能提示规则文件”。 有点像是：“告诉编辑器，Hexo 的 _config.yml 里有哪些合法字段，它们是什么类型，这样编辑器就能给你自动补全、检查错误。” 可以把它理解为： Hexo 配置文件的类型说明书（给编辑器看的，不是给 Hexo 本身看的） 然后在根目录创建一个.vccode 文件夹，里面再创建一个 settings.jso，复制过去之后，注意右击代码，进行格式化文档。 &#123; &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;, &quot;title&quot;: &quot;Hexo Configuration Schema&quot;, &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;subtitle&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;description&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;keywords&quot;: &#123; &quot;type&quot;: [&quot;string&quot;, &quot;array&quot;], &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125;, &quot;author&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;language&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;timezone&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;url&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;permalink&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;permalink_defaults&quot;: &#123; &quot;type&quot;: &quot;object&quot; &#125;, &quot;pretty_urls&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;trailing_index&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;trailing_html&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125; &#125; &#125;, &quot;source_dir&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;public_dir&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;tag_dir&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;archive_dir&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;category_dir&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;i18n_dir&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;new_post_name&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;default_layout&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;titlecase&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;external_link&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;enable&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;field&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;exclude&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125;, &quot;filename_case&quot;: &#123; &quot;type&quot;: &quot;number&quot; &#125;, &quot;render_drafts&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;post_asset_folder&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;relative_link&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;future&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;syntax_highlighter&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;highlight&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;enable&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;line_number&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;auto_detect&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;tab_replace&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;wrap&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;hljs&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125; &#125; &#125;, &quot;prismjs&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;preprocess&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;line_number&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;tab_replace&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125;, &quot;index_generator&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;path&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;per_page&quot;: &#123; &quot;type&quot;: &quot;number&quot; &#125;, &quot;order_by&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125;, &quot;category_map&quot;: &#123; &quot;type&quot;: &quot;object&quot; &#125;, &quot;tag_map&quot;: &#123; &quot;type&quot;: &quot;object&quot; &#125;, &quot;date_format&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;time_format&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;updated_option&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;per_page&quot;: &#123; &quot;type&quot;: &quot;number&quot; &#125;, &quot;pagination_dir&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;include&quot;: &#123; &quot;type&quot;: [&quot;array&quot;, &quot;string&quot;], &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125;, &quot;exclude&quot;: &#123; &quot;type&quot;: [&quot;array&quot;, &quot;string&quot;], &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125;, &quot;ignore&quot;: &#123; &quot;type&quot;: [&quot;array&quot;, &quot;string&quot;], &quot;items&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125;, &quot;theme&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;deploy&quot;: &#123; &quot;type&quot;: [&quot;object&quot;, &quot;array&quot;], &quot;items&quot;: &#123; &quot;type&quot;: &quot;object&quot; &#125;, &quot;properties&quot;: &#123; &quot;type&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;repo&quot;: &#123; &quot;type&quot;: [&quot;string&quot;, &quot;object&quot;] &#125;, &quot;branch&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;message&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125;, &quot;markdown&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;render&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;html&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;xhtmlOut&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;breaks&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;linkify&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;typographer&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125; &#125; &#125;, &quot;plugins&quot;: &#123; &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123; &quot;type&quot;: [&quot;string&quot;, &quot;array&quot;] &#125; &#125; &#125; &#125; &#125; &#125; settings.json 是什么？ VS Code 的配置文件，使用 JSON 格式存储各种设置。VS Code 会读取它来自定义编辑器行为 &#123; &quot;yaml.schemas&quot;: &#123; &quot;./hexo-schema.json&quot;: &quot;_config.yml&quot; &#125; &#125; (2) 安装 hexo-tips 这个插件用于提示块（info、warning、danger 卡片等），主题 Klise-enhanced 已支持。 安装： npm install hexo-tips --save 然后在 _config.yml 增加配置（可选）： tips: enable: true 使用示例（文章内）： &#123;% tips info %&#125; 这是一个信息提示 &#123;% endtips %&#125; (3) 安装文章加密插件：hexo-blog-encrypt 安装： npm install hexo-blog-encrypt --save 在 Hexo 全局 _config.yml 添加配置： encrypt: enable: true bg_color: &quot;#f2f2f2&quot; default_abstract: &quot;请输入密码查看正文&quot; 文章加密写法（Markdown front-matter）： title: 测试文章 date: 2025-01-01 password: 123456 abstract: 这篇文章被加密了 message: 输入密码继续阅读 tags: - test 这里是正文内容。 加密插件不需要额外命令，Hexo 会自动处理。 启动网站 最后就是清理缓存重新生成。 hexo clean hexo g hexo s 安装完毕后，浏览器复制 http://localhost:4000/，展示页面。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/tags/HEXO/"},{"name":"BLOG","slug":"BLOG","permalink":"http://example.com/tags/BLOG/"}]}],"categories":[{"name":"Misc","slug":"Misc","permalink":"http://example.com/categories/Misc/"},{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"},{"name":"MICS","slug":"MICS","permalink":"http://example.com/categories/MICS/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://example.com/categories/Wireshark/"},{"name":"KALI","slug":"KALI","permalink":"http://example.com/categories/KALI/"},{"name":"Kali","slug":"Kali","permalink":"http://example.com/categories/Kali/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://example.com/tags/Misc/"},{"name":"期末复习","slug":"期末复习","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"},{"name":"BLOG","slug":"BLOG","permalink":"http://example.com/tags/BLOG/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/tags/HEXO/"},{"name":"MARKDOWN","slug":"MARKDOWN","permalink":"http://example.com/tags/MARKDOWN/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"过滤","slug":"过滤","permalink":"http://example.com/tags/%E8%BF%87%E6%BB%A4/"},{"name":"编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"隐写","slug":"隐写","permalink":"http://example.com/tags/%E9%9A%90%E5%86%99/"},{"name":"命令","slug":"命令","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"dict","slug":"dict","permalink":"http://example.com/tags/dict/"}]}