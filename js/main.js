
(() => {
  // Ensure our DOM interactions run after DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    // Fix image paths: convert /img/ to /MYBLOG/img/ (handle root path)
    const baseUrl = document.querySelector('link[rel="alternate"]')?.href?.split('/atom.xml')[0] || '';
    const root = baseUrl ? baseUrl.replace(window.location.origin, '') : '';
    if (root) {
      document.querySelectorAll('img').forEach(img => {
        const src = img.getAttribute('src');
        if (src && src.startsWith('/img/') && !src.startsWith(root)) {
          img.setAttribute('src', root + src);
        }
      });
    }

    // Theme switch
    const body = document.body;
    const lamp = document.getElementById('mode');

    // set language name for code blocks (for both `figure.highlight` and plain `pre > code`)
    // helper: extract language name from class strings used by different renderers
    const extractLang = (str) => {
      if (!str) return null;
      // try common patterns: language-xxx, lang-xxx, highlight-xxx, brush:xxx
      // capture only the token (e.g. "python", "js", "bash")
      const m = str.match(/(?:language-|lang-|highlight-|brush:)?([A-Za-z0-9_+-]+)/i);
      return m ? m[1] : null;
    };

    // language display mapping: map common short codes to friendly names
    const langDisplayMap = {
      js: 'JavaScript',
      javascript: 'JavaScript',
      jsx: 'JavaScript (JSX)',
      ts: 'TypeScript',
      typescript: 'TypeScript',
      py: 'Python',
      python: 'Python',
      rb: 'Ruby',
      ruby: 'Ruby',
      sh: 'Shell',
      bash: 'Bash',
      zsh: 'Zsh',
      shell: 'Shell',
      ps1: 'PowerShell',
      powershell: 'PowerShell',
      html: 'HTML',
      css: 'CSS',
      json: 'JSON',
      xml: 'XML',
      sql: 'SQL',
      java: 'Java',
      c: 'C',
      cpp: 'C++',
      cplusplus: 'C++',
      cs: 'C#',
      csharp: 'C#',
      go: 'Go',
      rust: 'Rust',
      php: 'PHP',
      kotlin: 'Kotlin',
      swift: 'Swift',
      perl: 'Perl',
      lua: 'Lua',
      r: 'R',
      dockerfile: 'Dockerfile',
      plaintext: 'Text',
      text: 'Text',
      md: 'Markdown',
      markdown: 'Markdown'
    };

    const formatLang = (raw) => {
      if (!raw) return 'Code';
      const key = String(raw).trim().toLowerCase();
      // direct map
      if (langDisplayMap[key]) return langDisplayMap[key];
      // strip common prefixes if present
      const stripped = key.replace(/^(language-|lang-)/, '');
      if (langDisplayMap[stripped]) return langDisplayMap[stripped];
      // humanize: replace separators and capitalize words
      const human = stripped.replace(/[_-]/g, ' ').split(' ').map(w => w ? (w.charAt(0).toUpperCase() + w.slice(1)) : '').join(' ');
      return human || 'Code';
    };

    // first handle existing figure.highlight generated by some renderers
    // 通用去空行函数（供初次处理与 MutationObserver 使用）
    const trimBlankLinesIn = (root) => {
      if (!root) return;
      try {
        const processEl = (el) => {
          if (!el || !el.textContent) return;
          const lines = el.textContent.split(/\r?\n/);
          const filtered = lines.filter(l => l.trim() !== '');
          if (filtered.length > 0) {
            const newText = filtered.join('\n');
            if (newText !== el.textContent) el.textContent = newText;
          }
        };

        // 如果 root 本身就是 pre/code，直接处理
        if (root.tagName && /^(PRE|CODE)$/i.test(root.tagName)) processEl(root);

        // 以及处理后代 pre/code 元素
        if (root.querySelectorAll) {
          root.querySelectorAll('pre, code').forEach(processEl);
        }
      } catch (e) {
        console.warn('trimBlankLinesIn failed', e);
      }
    };
    let figures = document.querySelectorAll('figure.highlight');
    figures.forEach(function (item) {
      // try to detect from figure's own classes
      let cls = item.getAttribute('class') || '';
      let langName = null;
      const parts = cls.split(' ').filter(Boolean);
      for (const p of parts) {
        const candidate = extractLang(p);
        if (candidate && candidate.toLowerCase() !== 'plain') {
          langName = candidate;
          break;
        }
      }

      // fallback: try to detect from a descendant <code> element's class
      if (!langName) {
        const codeEl = item.querySelector('code');
        if (codeEl) {
          const cls2 = codeEl.getAttribute('class') || '';
          langName = extractLang(cls2);
        }
      }

      if (!langName) langName = 'Code';
      item.setAttribute('data-lang', formatLang(langName));

      // Display-time: 移除 code/pre 内的空行（只过滤完全为空或仅含空白的行）
      trimBlankLinesIn(item);
    });

    // also handle plain <pre><code class="language-xxx"> produced by many renderers
    let pres = document.querySelectorAll('pre');
    pres.forEach(function (pre) {
      // skip if inside a figure.highlight (already handled)
      if (pre.closest('figure.highlight')) return;

      // ensure pre has positioning and the same styling as .highlight by adding the class
      if (!pre.classList.contains('highlight')) pre.classList.add('highlight');

      const code = pre.querySelector('code');
      let langName = null;
      if (code) {
        const cls = code.getAttribute('class') || '';
        langName = extractLang(cls);
        // some renderers attach language to the <pre> itself
        if (!langName) {
          const preCls = pre.getAttribute('class') || '';
          langName = extractLang(preCls);
        }
      } else {
        const preCls = pre.getAttribute('class') || '';
        langName = extractLang(preCls);
      }

      if (!langName) langName = 'Code';
      pre.setAttribute('data-lang', formatLang(langName));

      // Display-time: 如果元素包含 <code>，对其文本移除空行；否则对 <pre> 自身处理
      trimBlankLinesIn(code || pre);
    });

    const toggleTheme = () => {
      // Check if dark theme is currently active
      const isDarkMode = body.getAttribute('data-theme') === 'dark';
      
      if (isDarkMode) {
        // Switch to light mode
        localStorage.setItem('theme', 'light');
        body.removeAttribute('data-theme');
      } else {
        // Switch to dark mode
        localStorage.setItem('theme', 'dark');
        body.setAttribute('data-theme', 'dark');
      }
    };

    if (lamp) {
      lamp.addEventListener('click', function (e) {
        e.preventDefault();
        toggleTheme();
      });
    }

    // Blur the content when the menu is open (guard existence)
    const cbox = document.getElementById('menu-trigger');
    if (cbox) {
      cbox.addEventListener('change', function () {
        const area = document.querySelector('.wrapper');
        if (!area) return;
        if (this.checked) {
          area.classList.add('blurry');
        } else {
          area.classList.remove('blurry');
        }
      });
    }

    // Toggle overlay and to-top buttons (guard existence)
    const toggleButton = document.getElementById('toggleButton');
    const overlay = document.getElementById('overlay');
    const closeButton = document.getElementById('closeButton');

    // helper to bind an event once per element (avoids duplicate bindings)
    const bindOnce = (el, eventName, handler, flag) => {
      if (!el) return;
      const key = flag || ('bind_' + eventName);
      if (el.dataset && el.dataset[key]) return;
      el.addEventListener(eventName, handler);
      if (el.dataset) el.dataset[key] = '1';
    };

    // centralize TOC close logic so all triggers use the same behavior
    const closeToc = () => {
      if (overlay) overlay.style.display = 'none';
      if (toggleButton) toggleButton.style.display = 'flex';
    };
    if (toggleButton && overlay) {
      bindOnce(toggleButton, 'click', function () {
        overlay.style.display = overlay.style.display === 'none' || overlay.style.display === '' ? 'flex' : 'none';
        toggleButton.style.display = 'none';
      }, 'toc_toggle');
    }

    if (closeButton && overlay && toggleButton) {
      bindOnce(closeButton, 'click', function () {
        closeToc();
      }, 'toc_close');
    }

    // Close TOC when clicking outside the content area inside the overlay
    if (overlay) {
      bindOnce(overlay, 'click', function (e) {
        // If click is not inside the .content panel, close the overlay
        if (!e.target.closest('.content')) {
          closeToc();
        }
      }, 'toc_overlay_click');
    }

    // Close TOC when clicking on empty area inside the content panel
    // but ignore clicks on interactive elements (links, buttons, inputs...)
    if (overlay) {
      const contentPanel = overlay.querySelector && overlay.querySelector('.content');
      if (contentPanel) {
        bindOnce(contentPanel, 'click', function (e) {
          const interactive = e.target.closest('a,button,input,textarea,select,[role="button"],[role="link"]');
          if (interactive) return; // don't close when clicking interactive elements
          // If target is inside content but not an interactive element -> close
          closeToc();
        }, 'toc_content_click');
      }
    }

    // to top button
    const toTopBtn = document.getElementById('toTopBtn');
    if (toTopBtn) {
      window.addEventListener('scroll', () => {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
          toTopBtn.style.display = 'flex';
        } else {
          toTopBtn.style.display = 'none';
        }
      });

      toTopBtn.addEventListener('click', function () {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    }

    // Code Copy Button: create once per .highlight and guard against errors
    try {
      // attach copy buttons to any element with .highlight (including pre we added the class to)
      document.querySelectorAll('.highlight').forEach(block => {
        // avoid adding multiple buttons if script runs repeatedly
        if (block.querySelector('.code-copy-btn')) return;

        const btn = document.createElement('button');
        btn.className = 'code-copy-btn';
        btn.setAttribute('type', 'button');
        btn.setAttribute('aria-label', '复制代码');
        btn.title = '复制代码';
        btn.textContent = '复制';

        btn.addEventListener('click', async (e) => {
          e.preventDefault();
          // Prefer actual code text inside a <code> if present, otherwise use the block text
          const codeEl = block.querySelector('code') || block.querySelector('pre') || block;
          const raw = codeEl ? codeEl.innerText : block.innerText;

          // 用户需求：在复制时忽略代码/高亮块中的空行（只过滤完全为空或仅含空白的行）
          let code = raw;
          try {
            const lines = String(raw || '').split(/\r?\n/);
            const filtered = lines.filter(l => l.trim() !== '');
            // 如果过滤后还有内容，则使用过滤后的文本；否则回退到原始文本
            if (filtered.length > 0) code = filtered.join('\n');

            await navigator.clipboard.writeText(code);
            btn.textContent = '已复制';
            setTimeout(() => (btn.textContent = '复制'), 1200);
          } catch (err) {
            console.debug('clipboard write error', err);
            btn.textContent = '复制失败';
            setTimeout(() => (btn.textContent = '复制'), 1200);
          }
        });

        // append button as last child so absolute positioning works
        block.appendChild(btn);
      });
    } catch (e) {
      // swallow errors so other scripts aren't blocked
      console.warn('Code copy init failed', e);
    }

    // TOC anchor fix: ensure headings have ids and TOC links point to them
    try {
      const contentEl = document.querySelector('main.page-content .page-content');
      if (contentEl) {
        const headings = contentEl.querySelectorAll('h1,h2,h3,h4,h5,h6');
        const slugify = (s) => {
          if (!s) return '';
          return s
            .toString()
            .trim()
            .toLowerCase()
            // keep CJK, word characters, spaces and hyphens
            .replace(/[^\u4e00-\u9fa5\w\s-]/g, '')
            .replace(/\s+/g, '-');
        };

        const map = Object.create(null);
        headings.forEach(h => {
          let id = h.id && h.id.length ? h.id : slugify(h.innerText || h.textContent);
          if (!id) id = 'heading-' + Math.random().toString(36).slice(2, 8);
          const base = id;
          let i = 1;
          while (document.getElementById(id)) {
            id = base + '-' + (i++);
          }
          h.id = id;
          map[(h.innerText || h.textContent).trim()] = id;
        });

        document.querySelectorAll('.toc a.toc-link').forEach(a => {
          const text = (a.innerText || a.textContent || '').trim();
          if (!text) return;
          const id = map[text] || slugify(text);
          if (id) a.setAttribute('href', '#' + id);
        });
      }
    } catch (err) {
      console.warn('TOC anchor init failed', err);
    }

    // 修复：避免 `.info-block` 中的 `# ` 被渲染为标题
    // 1) 将 info-block 内被渲染成 <h1>-<h6> 的元素替换为普通段落，前面加上单个 `#`（无空格）
    // 2) 在 info-block 的 code/pre 内，去掉行首 `# ` 的空格（`# ` -> `#`）
    try {
      document.querySelectorAll('.info-block').forEach(block => {
        // 处理被渲染成标题的情况（比如原文写了 `# 标题`）
        ['h1','h2','h3','h4','h5','h6'].forEach(tag => {
          block.querySelectorAll(tag).forEach(h => {
            const text = (h.textContent || '').trim();
            const p = document.createElement('p');
            // 按用户要求，使用单个 `#` 且不加空格
            p.textContent = '#' + text;
            // 保留视觉上与 info-block 内容一致的行高/间距
            p.style.margin = getComputedStyle(h).margin;
            h.parentNode.replaceChild(p, h);
          });
        });

        // 处理 info-block 内的 code / pre 文本：把每行开头的 `# ` 替换成 `#`，并移除空行
        block.querySelectorAll('pre, code').forEach(el => {
          // 使用 textContent 操作以保留纯文本（避免 HTML 注入）
          if (!el.textContent) return;
          // 1) 行首的 '# ' -> '#'
          let newText = el.textContent.replace(/(^|\n)#\s+/g, (m, p1) => p1 + '#');
          // 2) 移除仅含空白的行（显示级过滤）
          try {
            const lines = newText.split(/\r?\n/);
            const filtered = lines.filter(l => l.trim() !== '');
            if (filtered.length > 0) newText = filtered.join('\n');
          } catch (e) {
            console.warn('filter blank lines in info-block failed', e);
          }

          if (newText !== el.textContent) {
            // 对于 <code> 使用 textContent；对于 <pre> 也同样安全
            el.textContent = newText;
          }
        });
      });
    } catch (err) {
      console.warn('info-block hash normalization failed', err);
    }

    // 如果页面上存在后续运行的高亮器（如 highlight.js）或其它脚本，会在 DOMContentLoaded 之后修改代码区域，
    // 我们使用 MutationObserver 监听新增/变化的节点，确保在高亮器完成后仍能去除空行。
    try {
      const debounced = (fn, wait = 150) => {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...args), wait);
        };
      };

      const observerCb = debounced((mutations) => {
        mutations.forEach(m => {
          if (m.addedNodes && m.addedNodes.length) {
            m.addedNodes.forEach(n => {
              if (n.nodeType !== 1) return;
              // 直接对新增的节点或其后代执行去空行
              if (n.matches && (n.matches('pre, code, .highlight, .info-block') || n.querySelector && n.querySelector('pre, code, .highlight, .info-block'))) {
                trimBlankLinesIn(n);
              }
            });
          }
          if (m.type === 'characterData' && m.target && m.target.parentNode) {
            const parent = m.target.parentNode;
            if (parent && (parent.matches && parent.matches('pre, code'))) trimBlankLinesIn(parent);
          }
        });
      });

      const mo = new MutationObserver(observerCb);
      mo.observe(document.body, { childList: true, subtree: true, characterData: true });
    } catch (e) {
      console.warn('MutationObserver for trimming failed', e);
    }
  });

})();

